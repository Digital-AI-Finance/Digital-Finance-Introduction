<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 3.3: Wallets Transactions | Introduction to Digital Finance</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        :root {
            --mlpurple: #3333B2;
            --mlblue: #0066CC;
            --quiz-accent: #8b5cf6;
            --quiz-light: #ede9fe;
            --correct: #22c55e;
            --correct-bg: #dcfce7;
            --incorrect: #ef4444;
            --incorrect-bg: #fee2e2;
            --bg: #f6f8fa;
            --card-bg: #ffffff;
            --text: #24292e;
            --text-secondary: #586069;
            --border: #e1e4e8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.4;
            min-height: 100vh;
        }

        .nav {
            background: linear-gradient(135deg, var(--mlpurple), var(--mlblue));
            color: white;
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nav-title { font-weight: 600; font-size: 14px; }
        .nav-links { display: flex; gap: 16px; }
        .nav-links a { color: white; text-decoration: none; font-size: 12px; opacity: 0.9; }
        .nav-links a:hover { opacity: 1; }

        .quiz-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 12px;
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 4px;
        }
        .quiz-title { font-size: 16px; font-weight: 600; color: var(--mlpurple); }
        .quiz-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }
        .stat-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .stat-progress { background: var(--quiz-light); color: var(--quiz-accent); }
        .stat-score { background: var(--correct-bg); color: var(--correct); }

        .progress-bar-container {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-bottom: 12px;
        }
        .progress-bar {
            height: 100%;
            background: var(--quiz-accent);
            border-radius: 2px;
            transition: width 0.3s;
        }

        /* Three-column layout */
        .questions-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            min-height: 280px;
        }

        .question-card.answered { opacity: 0.7; }

        .question-card.correct-card {
            border: 2px solid var(--correct);
            background: linear-gradient(to bottom, var(--correct-bg), var(--card-bg));
        }

        .question-card.incorrect-card {
            border: 2px solid var(--incorrect);
            background: linear-gradient(to bottom, var(--incorrect-bg), var(--card-bg));
        }

        .q-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .q-number {
            background: var(--quiz-light);
            color: var(--quiz-accent);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .q-status { font-size: 14px; }

        .q-text {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 10px;
            line-height: 1.4;
            flex-grow: 0;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-grow: 1;
        }

        .option-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            min-height: 44px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            font-size: 12px;
        }

        .option-btn:hover:not(.disabled) {
            border-color: var(--quiz-accent);
            background: var(--quiz-light);
        }

        .option-btn.correct {
            border-color: var(--correct);
            background: var(--correct-bg);
        }

        .option-btn.incorrect {
            border-color: var(--incorrect);
            background: var(--incorrect-bg);
        }

        .option-btn.disabled { cursor: default; }

        .option-letter {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }

        .option-btn.correct .option-letter {
            background: var(--correct);
            color: white;
        }

        .option-btn.incorrect .option-letter {
            background: var(--incorrect);
            color: white;
        }

        .option-text { flex: 1; }

        .feedback {
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.4;
            display: none;
        }

        .feedback.show { display: block; }
        .feedback.correct { background: var(--correct-bg); color: #166534; }
        .feedback.incorrect { background: var(--incorrect-bg); color: #991b1b; }

        /* Results */
        .results-card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 32px;
            text-align: center;
            max-width: 500px;
            margin: 40px auto;
            display: none;
        }
        .results-card.show { display: block; }
        .results-icon { font-size: 48px; margin-bottom: 8px; }
        .results-score { font-size: 36px; font-weight: 700; color: var(--quiz-accent); }
        .results-label { font-size: 14px; color: var(--text-secondary); margin-bottom: 16px; }
        .results-grade {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .grade-a { background: #dcfce7; color: #166534; }
        .grade-b { background: #dbeafe; color: #1e40af; }
        .grade-c { background: #fef3c7; color: #92400e; }
        .grade-d { background: #fed7aa; color: #9a3412; }
        .grade-f { background: #fee2e2; color: #991b1b; }

        .results-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            text-decoration: none;
        }
        .btn-primary { background: var(--quiz-accent); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-secondary { background: var(--card-bg); color: var(--text); border: 1px solid var(--border); }

        /* Next button container */
        .next-btn-container {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        .btn-next {
            padding: 10px 32px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            background: var(--quiz-accent);
            color: white;
            transition: all 0.2s;
            display: none;
        }
        .btn-next:hover { background: #7c3aed; transform: scale(1.02); }
        .btn-next.show { display: inline-block; }
        .btn-next:disabled { opacity: 0.5; cursor: not-allowed; }

        @media (max-width: 900px) {
            .questions-row { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 600px) {
            .questions-row { grid-template-columns: 1fr; }
            .question-card { min-height: auto; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-title">Quiz 3.3: Wallets Transactions</div>
        <div class="nav-links">
            <a href="../index.html">Dashboard</a>
            
            <a href="https://github.com/Digital-AI-Finance/Digital-Finance-Introduction" target="_blank">GitHub</a>
        </div>
    </nav>

    <main class="quiz-container">
        <div class="quiz-header">
            <div class="quiz-title">Quiz 3.3: Wallets Transactions</div>
            <div class="quiz-stats">
                <span class="stat-badge stat-progress" id="progressBadge">0/20</span>
                <span class="stat-badge stat-score" id="scoreBadge">Score: 0</span>
            </div>
        </div>

        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>

        <div class="questions-row" id="questionsRow"></div>

        <div class="next-btn-container">
            <button class="btn-next" id="nextBtn" onclick="loadNextQuestions()">Next</button>
        </div>

        <div class="results-card" id="resultsCard">
            <div class="results-icon" id="resultsIcon"></div>
            <div class="results-score" id="resultsScore"></div>
            <div class="results-label">Correct Answers</div>
            <div class="results-grade" id="resultsGrade"></div>
            <div class="results-buttons">
                <button class="btn btn-primary" onclick="restartQuiz()">Try Again</button>
                <a href="../index.html" class="btn btn-secondary">Dashboard</a>
            </div>
        </div>
    </main>

    <script>
        const quizData = {
            questions: [
                {
                                "id": 1,
                                "question": "In Bitcoin's UTXO model, what happens when Alice wants to send 0.3 BTC but only has a single UTXO of 0.5 BTC?",
                                "options": {
                                                "A": "The transaction is rejected because the amounts don't match exactly",
                                                "B": "She creates a transaction with the 0.5 BTC UTXO as input, 0.3 BTC to the recipient, and 0.2 BTC back to herself as change",
                                                "C": "The blockchain automatically splits the UTXO into smaller pieces before sending",
                                                "D": "The remaining 0.2 BTC is automatically sent to miners as a fee"
                                },
                                "correct": "B",
                                "explanation": "In the UTXO model, transaction inputs must consume entire UTXOs. If Alice has a 0.5 BTC UTXO but only wants to send 0.3 BTC, she creates a transaction that uses the full 0.5 BTC UTXO as input, sends 0.3 BTC to the recipient's address, and returns 0.2 BTC to herself at a new address (the change address). The UTXO model doesn't support partial spending of UTXOs - they must be fully consumed, with any remainder explicitly returned as change.",
                                "difficulty": "medium"
                },
                {
                                "id": 2,
                                "question": "What is the primary advantage of Ethereum's account-based model over Bitcoin's UTXO model?",
                                "options": {
                                                "A": "Account-based models are more secure against double-spending attacks",
                                                "B": "Account-based models simplify state tracking and smart contract interactions by maintaining persistent account balances",
                                                "C": "Account-based models require less storage space on the blockchain",
                                                "D": "Account-based models provide better privacy by hiding transaction history"
                                },
                                "correct": "B",
                                "explanation": "The account-based model maintains a persistent state for each account (like a bank account), making it much simpler to track balances and interact with smart contracts. Instead of tracking unspent outputs, the system just checks the account balance. This is particularly beneficial for smart contracts that need to maintain state and perform complex operations. However, it's worth noting that the UTXO model actually provides better privacy and natural parallelization, but the account model's simplicity makes it superior for smart contract platforms.",
                                "difficulty": "medium"
                },
                {
                                "id": 3,
                                "question": "Which statement correctly describes a key difference between UTXO and account-based models?",
                                "options": {
                                                "A": "UTXO models store account balances in a global state database, while account models compute balances from transaction history",
                                                "B": "UTXO models compute balances by summing unspent outputs, while account models store balances directly in account states",
                                                "C": "Both models store balances identically but differ only in transaction format",
                                                "D": "UTXO models require smart contracts to function, while account models work with simple transfers only"
                                },
                                "correct": "B",
                                "explanation": "This is a fundamental architectural difference. In UTXO systems like Bitcoin, there are no 'account balances' stored anywhere - your balance is calculated by summing all unspent transaction outputs that you can unlock with your private keys. In account-based systems like Ethereum, each account has a balance field stored in the global state, which is updated directly by transactions. This makes account-based systems conceptually simpler (like a bank account) but UTXO systems better for parallelization and privacy.",
                                "difficulty": "hard"
                },
                {
                                "id": 4,
                                "question": "In a blockchain transaction, what are transaction inputs and outputs in the UTXO model?",
                                "options": {
                                                "A": "Inputs are the sender's public keys, and outputs are the recipient's public keys",
                                                "B": "Inputs are references to previous unspent outputs being spent, and outputs are new unspent outputs being created",
                                                "C": "Inputs are the transaction amounts, and outputs are the transaction fees",
                                                "D": "Inputs are wallet addresses, and outputs are blockchain addresses"
                                },
                                "correct": "B",
                                "explanation": "In the UTXO model, transaction inputs reference specific unspent transaction outputs (UTXOs) from previous transactions that the sender is authorized to spend. Transaction outputs create new UTXOs that specify amounts and conditions for future spending. Think of it like checks: inputs are old checks you're cashing in, and outputs are new checks you're writing. Each output becomes a potential input for future transactions, creating a chain of custody for every coin.",
                                "difficulty": "easy"
                },
                {
                                "id": 5,
                                "question": "Why do Bitcoin transactions typically include a change address?",
                                "options": {
                                                "A": "To confuse blockchain analysis and improve privacy",
                                                "B": "To pay the transaction fee to miners",
                                                "C": "Because UTXOs must be spent entirely, any difference between the input amount and intended payment must be returned as change",
                                                "D": "To create a backup copy of the transaction"
                                },
                                "correct": "C",
                                "explanation": "The UTXO model requires that transaction inputs be consumed entirely. If you have a 1 BTC UTXO but only want to send 0.3 BTC, you cannot partially spend it. Instead, you must consume the entire 1 BTC UTXO and create two outputs: 0.3 BTC to the recipient and 0.7 BTC back to yourself (minus the transaction fee). The output back to yourself goes to a change address. This is analogous to paying for a $3 item with a $10 bill and receiving $7 in change. Many wallets automatically create new change addresses for privacy.",
                                "difficulty": "medium"
                },
                {
                                "id": 6,
                                "question": "How is a transaction fee calculated in a typical blockchain transaction?",
                                "options": {
                                                "A": "Fee = Transaction amount × Percentage rate",
                                                "B": "Fee = Gas units consumed × Gas price per unit",
                                                "C": "Fee = Fixed amount determined by the blockchain protocol",
                                                "D": "Fee = Number of recipients × Base fee"
                                },
                                "correct": "B",
                                "explanation": "Transaction fees in blockchains like Ethereum are calculated as Gas Units × Gas Price. Gas units represent the computational complexity of the transaction (e.g., a simple transfer uses 21,000 gas, while complex smart contract interactions use more). The gas price (typically measured in Gwei) is the amount you're willing to pay per unit of gas. As shown in the notebook, a simple transfer at 25 Gwei costs: 21,000 gas × 25 Gwei = 525,000 Gwei = 0.000525 ETH. This differs from traditional payment systems that charge percentage-based fees.",
                                "difficulty": "easy"
                },
                {
                                "id": 7,
                                "question": "What drives fee market dynamics in proof-of-work and proof-of-stake blockchains?",
                                "options": {
                                                "A": "Government regulations and central bank policies",
                                                "B": "Competition among users for limited block space, with higher fees incentivizing faster inclusion",
                                                "C": "The price of electricity needed to mine blocks",
                                                "D": "The number of validators in the network"
                                },
                                "correct": "B",
                                "explanation": "Block space is a scarce resource - each block can only include a limited number of transactions. When many users want their transactions included quickly, they compete by offering higher fees. Miners/validators prioritize transactions with higher fees to maximize their rewards. The notebook demonstrates this with examples: during normal network conditions, 25 Gwei might suffice, but during congestion (like NFT drops), users might pay 200+ Gwei for immediate inclusion. This creates a dynamic auction market where fee prices fluctuate based on supply (block space) and demand (pending transactions).",
                                "difficulty": "medium"
                },
                {
                                "id": 8,
                                "question": "What is the mempool in blockchain networks?",
                                "options": {
                                                "A": "A secure storage location for private keys",
                                                "B": "A waiting area where unconfirmed transactions are held before being included in a block",
                                                "C": "A permanent archive of all historical transactions",
                                                "D": "A pool of rewards distributed to miners"
                                },
                                "correct": "B",
                                "explanation": "The mempool (memory pool) is where valid but unconfirmed transactions wait after being broadcast to the network but before being included in a block. Each node maintains its own mempool, and miners/validators select transactions from their mempool to include in the next block, typically prioritizing those with higher fees. The mempool acts like a waiting room - transactions enter when broadcast, wait for a miner to pick them up, and leave once included in a block. During high network activity, the mempool can become congested with thousands of pending transactions.",
                                "difficulty": "easy"
                },
                {
                                "id": 9,
                                "question": "What happens during the transaction confirmation process after a transaction is included in a block?",
                                "options": {
                                                "A": "The transaction is immediately final and cannot be reversed",
                                                "B": "The transaction receives one confirmation, and subsequent blocks add more confirmations, increasing certainty",
                                                "C": "The transaction is sent back to the mempool for re-verification",
                                                "D": "The transaction fee is immediately returned to the sender"
                                },
                                "correct": "B",
                                "explanation": "When a transaction is included in a block, it receives its first confirmation. Each subsequent block added to the chain provides an additional confirmation. For example, if your transaction is in block 100 and the current block is 103, you have 3 confirmations. More confirmations mean greater security because an attacker would need to reorganize more blocks to reverse the transaction. As the notebook mentions, Ethereum achieves finality after about 15 minutes (2 epochs), while Bitcoin typically recommends 6 confirmations (~60 minutes) for high-value transactions.",
                                "difficulty": "easy"
                },
                {
                                "id": 10,
                                "question": "Why do exchanges and merchants often require multiple confirmations before considering a transaction final?",
                                "options": {
                                                "A": "To allow time for customer service to verify the transaction",
                                                "B": "To protect against chain reorganizations that could reverse a transaction included in a recently mined block",
                                                "C": "Because blockchain protocols require a minimum number of confirmations by law",
                                                "D": "To give users time to cancel the transaction if they made a mistake"
                                },
                                "correct": "B",
                                "explanation": "Multiple confirmations protect against chain reorganizations (reorgs). In a blockchain, occasionally two miners find blocks simultaneously, creating a temporary fork. Eventually one chain becomes longer and is accepted as canonical, orphaning the other. If a transaction was in the orphaned block, it returns to the mempool as unconfirmed. The more confirmations (deeper in the chain), the more computationally expensive it becomes for an attacker to reorganize the chain and reverse the transaction. This is why exchanges might require 6+ confirmations for Bitcoin deposits - each confirmation exponentially increases security.",
                                "difficulty": "medium"
                },
                {
                                "id": 11,
                                "question": "How can an attacker execute a double-spend attack on an unconfirmed transaction?",
                                "options": {
                                                "A": "By hacking the recipient's wallet and stealing the funds after the transaction",
                                                "B": "By broadcasting two conflicting transactions spending the same UTXO, with the second transaction (paying themselves) potentially being mined instead",
                                                "C": "By reversing the transaction using their private key",
                                                "D": "By convincing miners to delete the transaction from the blockchain"
                                },
                                "correct": "B",
                                "explanation": "A double-spend attack on an unconfirmed transaction works by exploiting the time between broadcast and confirmation. An attacker broadcasts transaction A (paying a merchant) and immediately broadcasts conflicting transaction B (paying themselves) with a higher fee. If transaction B gets mined first, transaction A becomes invalid and the merchant never receives payment. This is why the notebook emphasizes that transactions in the mempool are not secure - only confirmed transactions provide reasonable security. This is also why 'zero-confirmation' transactions (accepting payment without waiting for block inclusion) are risky for high-value items.",
                                "difficulty": "hard"
                },
                {
                                "id": 12,
                                "question": "What is Replace-by-Fee (RBF) and when is it useful?",
                                "options": {
                                                "A": "A mechanism to cancel any transaction by paying a replacement fee to miners",
                                                "B": "A feature that allows replacing an unconfirmed transaction with a new version that pays a higher fee, useful when the original fee was too low",
                                                "C": "A protocol for automatically adjusting fees based on network conditions",
                                                "D": "A method for merchants to request higher fees from customers"
                                },
                                "correct": "B",
                                "explanation": "Replace-by-Fee (RBF) allows users to 'speed up' a stuck transaction by broadcasting a replacement transaction with the same inputs but a higher fee. This is useful when you set the fee too low and your transaction is stuck in the mempool for a long time. Miners will accept the replacement because it pays them more. RBF must be signaled when creating the original transaction (opt-in RBF). For example, if you sent a transaction with 10 Gwei but network fees spiked to 50 Gwei, you could create an RBF transaction with 55 Gwei to get it confirmed faster. The original transaction becomes invalid once the replacement is mined.",
                                "difficulty": "hard"
                },
                {
                                "id": 13,
                                "question": "How does Child-Pays-For-Parent (CPFP) help stuck transactions?",
                                "options": {
                                                "A": "It allows miners to automatically increase fees on old transactions",
                                                "B": "The recipient creates a new transaction spending the unconfirmed output with a high fee, incentivizing miners to include both transactions",
                                                "C": "It splits the transaction into smaller pieces that are easier to process",
                                                "D": "It moves the transaction to a faster blockchain"
                                },
                                "correct": "B",
                                "explanation": "Child-Pays-For-Parent (CPFP) is an elegant solution when the sender can't or won't use RBF. The recipient creates a new transaction (child) that spends the output of the stuck transaction (parent), attaching a high fee to the child transaction. Miners are incentivized to include both the parent and child together because they can only collect the child's high fee if they also mine the parent. For example, if Alice sent you 1 BTC with a low fee and it's stuck, you can spend that unconfirmed 1 BTC with a very high fee. Miners will include both transactions to capture your high fee, effectively 'rescuing' the stuck parent transaction.",
                                "difficulty": "hard"
                },
                {
                                "id": 14,
                                "question": "What is transaction batching and why does it improve efficiency?",
                                "options": {
                                                "A": "Combining multiple payments to different recipients into a single transaction, reducing total fees and blockchain space usage",
                                                "B": "Grouping transactions by type for faster processing",
                                                "C": "Storing multiple transactions in computer memory before sending them",
                                                "D": "Automatically retrying failed transactions"
                                },
                                "correct": "A",
                                "explanation": "Transaction batching combines multiple payments into a single transaction. Instead of creating 100 separate transactions (each using 21,000 gas), you create one transaction with 100 outputs (using perhaps 21,000 + 99×5,000 gas = ~516,000 gas). This saves approximately 1.6 million gas compared to individual transactions. Exchanges and payment processors use batching extensively to reduce costs. For example, when Coinbase processes daily withdrawals, instead of sending thousands of individual transactions, they batch hundreds of payments into single transactions. This reduces fees, blockchain bloat, and network congestion.",
                                "difficulty": "medium"
                },
                {
                                "id": 15,
                                "question": "What factors determine the size (and thus cost) of a blockchain transaction?",
                                "options": {
                                                "A": "The transaction amount and the recipient's location",
                                                "B": "The number of inputs, outputs, and additional data (like smart contract calls or signatures)",
                                                "C": "The time of day and network traffic only",
                                                "D": "The cryptocurrency price and market volatility"
                                },
                                "correct": "B",
                                "explanation": "Transaction size depends on its data structure: number of inputs, number of outputs, signature data, and any additional data (like smart contract function calls). In Bitcoin's UTXO model, a transaction with 3 inputs and 2 outputs is larger than one with 1 input and 1 output. In Ethereum, the notebook shows a simple transfer uses 21,000 gas, but an ERC-20 token transfer uses ~65,000 gas, and a Uniswap swap uses ~150,000 gas. More complex operations (more computational steps, more data storage) require more gas. Smart contract interactions can add significant size through function calls and parameters encoded in the input data field.",
                                "difficulty": "medium"
                },
                {
                                "id": 16,
                                "question": "What problem did SegWit (Segregated Witness) solve regarding transaction malleability?",
                                "options": {
                                                "A": "It prevented miners from charging excessive fees",
                                                "B": "It fixed the vulnerability where transaction IDs could be altered before confirmation without invalidating the transaction, which broke multi-layer protocols",
                                                "C": "It eliminated all blockchain security vulnerabilities",
                                                "D": "It made all transactions completely anonymous"
                                },
                                "correct": "B",
                                "explanation": "Transaction malleability was a critical issue where the transaction ID (hash) could be changed by slightly modifying the signature data without invalidating the transaction. This created problems for protocols that relied on unconfirmed transaction IDs, such as the Lightning Network. If someone built a second transaction that depended on the first transaction's ID, and that ID changed, the second transaction would become invalid. SegWit solved this by separating (segregating) the signature data from the transaction data used to calculate the ID, making the ID immutable once the transaction is created. This fix was essential for enabling Layer 2 solutions.",
                                "difficulty": "hard"
                },
                {
                                "id": 17,
                                "question": "How does transaction finality differ between Bitcoin and Ethereum?",
                                "options": {
                                                "A": "Bitcoin achieves finality instantly while Ethereum requires 24 hours",
                                                "B": "Bitcoin uses probabilistic finality (more confirmations = more secure) while Ethereum after The Merge has explicit finality at 2 epochs (~15 minutes)",
                                                "C": "Both networks achieve finality in exactly the same way",
                                                "D": "Ethereum has no finality mechanism while Bitcoin does"
                                },
                                "correct": "B",
                                "explanation": "Bitcoin uses probabilistic finality - transactions are never 100% final, but become exponentially more secure with each confirmation. After 6 confirmations (~60 minutes), reversing a transaction is practically impossible but theoretically possible with enough hash power. Ethereum post-Merge (proof-of-stake) has explicit finality through the Casper FFG mechanism: after 2 epochs (~15 minutes), blocks are finalized and cannot be reverted without slashing at least 1/3 of all staked ETH (billions of dollars). As mentioned in the notebook, this represents a fundamental difference between PoW (probabilistic finality) and PoS (economic finality) systems.",
                                "difficulty": "hard"
                },
                {
                                "id": 18,
                                "question": "Why is block space considered a scarce resource in blockchain networks?",
                                "options": {
                                                "A": "Because storage devices are expensive",
                                                "B": "Because blocks have size or gas limits to ensure nodes can process them quickly, creating competition among transactions for inclusion",
                                                "C": "Because miners artificially restrict block sizes to increase fees",
                                                "D": "Because governments regulate the number of transactions allowed"
                                },
                                "correct": "B",
                                "explanation": "Block space is intentionally limited to ensure the network remains decentralized. If blocks were unlimited, only powerful computers could run full nodes, centralizing the network. Ethereum has a gas limit per block (shown in the notebook as 30,000,000), meaning only transactions totaling that much gas can fit. Bitcoin has a block size limit. These limits ensure that even modest computers can validate blocks quickly. The notebook demonstrates this scarcity: during normal times, gas costs 25 Gwei, but during congestion (NFT drops), it can spike to 200+ Gwei as users compete for limited space. This scarcity is fundamental to blockchain economics.",
                                "difficulty": "medium"
                },
                {
                                "id": 19,
                                "question": "In Ethereum's EIP-1559 fee structure, what is the difference between the priority fee and the base fee?",
                                "options": {
                                                "A": "Priority fee is paid to validators and base fee is paid to the government",
                                                "B": "Priority fee is an optional tip paid to validators for faster inclusion, while base fee is algorithmically determined and burned",
                                                "C": "Priority fee is for smart contracts and base fee is for simple transfers",
                                                "D": "They are the same thing with different names"
                                },
                                "correct": "B",
                                "explanation": "EIP-1559 (implemented August 2021) introduced a two-tier fee system. The base fee is algorithmically adjusted based on network congestion and is burned (destroyed, not paid to anyone), creating deflationary pressure on ETH. The priority fee (tip) is an optional payment to validators to incentivize them to include your transaction faster. As shown in the notebook, the total fee formula is: (Base Fee + Priority Fee) × Gas Used. For example, with a 20 Gwei base fee and 2 Gwei priority fee, a 21,000 gas transfer costs: 22 × 21,000 = 462,000 Gwei = 0.000462 ETH. Users can increase priority fees during congestion for faster inclusion.",
                                "difficulty": "medium"
                },
                {
                                "id": 20,
                                "question": "Describe the complete lifecycle of a blockchain transaction from creation to final confirmation.",
                                "options": {
                                                "A": "Create transaction → Store in blockchain → Pay fee → Receive confirmation",
                                                "B": "Create and sign transaction → Broadcast to network → Enter mempool → Selected by miner/validator → Included in block → Confirmed → Achieves finality after multiple confirmations",
                                                "C": "Sign with private key → Send to recipient → Automatic confirmation",
                                                "D": "Submit to exchange → Verification → Blockchain entry → Completion"
                                },
                                "correct": "B",
                                "explanation": "The complete transaction lifecycle has distinct stages: (1) User creates transaction with details (from, to, amount, gas) and signs it with private key, (2) Transaction is broadcast to network nodes, (3) Nodes validate and add it to their mempool, (4) Miners/validators select transactions (usually by fee), (5) Transaction is included in a block, (6) Block is added to the chain (first confirmation), (7) Subsequent blocks provide additional confirmations, (8) After sufficient confirmations (6 for Bitcoin, 2 epochs for Ethereum finality), the transaction achieves practical finality. The notebook emphasizes this lifecycle when explaining that mempool transactions are unconfirmed and potentially reversible, while confirmed transactions gain security with each additional block.",
                                "difficulty": "easy"
                }
]
        };

        const state = {
            currentIndex: 0,
            answers: {},
            score: 0,
            displayedQuestions: [],
            pendingSlots: []
        };

        const questionsRow = document.getElementById('questionsRow');
        const progressBar = document.getElementById('progressBar');
        const progressBadge = document.getElementById('progressBadge');
        const scoreBadge = document.getElementById('scoreBadge');
        const resultsCard = document.getElementById('resultsCard');
        const nextBtn = document.getElementById('nextBtn');

        function initQuiz() {
            state.currentIndex = 0;
            state.answers = {};
            state.score = 0;
            state.displayedQuestions = [];
            state.pendingSlots = [];

            resultsCard.classList.remove('show');
            questionsRow.style.display = 'grid';
            nextBtn.classList.remove('show');

            // Show first 3 questions
            for (let i = 0; i < 3 && i < quizData.questions.length; i++) {
                state.displayedQuestions.push(i);
            }
            state.currentIndex = Math.min(3, quizData.questions.length);

            renderQuestions();
            updateStats();
        }

        function renderQuestions() {
            questionsRow.innerHTML = '';

            state.displayedQuestions.forEach((qIdx, slot) => {
                const q = quizData.questions[qIdx];
                const answered = state.answers[q.id] !== undefined;
                const isCorrect = answered && state.answers[q.id] === q.correct;
                const isIncorrect = answered && state.answers[q.id] !== q.correct;

                const card = document.createElement('div');
                card.className = 'question-card';
                if (isCorrect) card.classList.add('correct-card', 'answered');
                if (isIncorrect) card.classList.add('incorrect-card', 'answered');

                card.innerHTML = `
                    <div class="q-header">
                        <span class="q-number">Q${qIdx + 1}</span>
                        ${answered ? `<span class="q-status">${isCorrect ? '&#10004;' : '&#10008;'}</span>` : ''}
                    </div>
                    <div class="q-text">${q.question}</div>
                    <div class="options" data-qid="${q.id}" data-slot="${slot}">
                        ${['A','B','C','D'].map(letter => {
                            let optClass = 'option-btn';
                            if (answered) {
                                optClass += ' disabled';
                                if (letter === q.correct) optClass += ' correct';
                                else if (letter === state.answers[q.id]) optClass += ' incorrect';
                            }
                            return `
                                <button class="${optClass}" data-letter="${letter}" ${answered ? 'disabled' : ''}>
                                    <span class="option-letter">${letter}</span>
                                    <span class="option-text">${q.options[letter]}</span>
                                </button>
                            `;
                        }).join('')}
                    </div>
                    <div class="feedback ${answered ? 'show' : ''} ${isCorrect ? 'correct' : 'incorrect'}">
                        ${answered ? (isCorrect ? '&#10004; ' : `&#10008; Answer: ${q.correct}. `) + q.explanation : ''}
                    </div>
                `;

                // Add click handlers
                if (!answered) {
                    card.querySelectorAll('.option-btn').forEach(btn => {
                        btn.addEventListener('click', () => handleAnswer(qIdx, slot, btn.dataset.letter));
                    });
                }

                questionsRow.appendChild(card);
            });

            renderMath();
        }

        function handleAnswer(qIdx, slot, letter) {
            const q = quizData.questions[qIdx];
            state.answers[q.id] = letter;

            if (letter === q.correct) state.score++;

            // Track this slot as pending replacement
            if (!state.pendingSlots.includes(slot)) {
                state.pendingSlots.push(slot);
            }

            updateStats();
            renderQuestions();

            // Check if all questions answered
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                // Short delay then show results
                setTimeout(showResults, 800);
            } else if (state.currentIndex < quizData.questions.length && state.pendingSlots.length > 0) {
                // Show Next button if there are more questions and pending slots
                nextBtn.classList.add('show');
            }
        }

        function loadNextQuestions() {
            // Replace pending slots with new questions
            while (state.pendingSlots.length > 0 && state.currentIndex < quizData.questions.length) {
                const slot = state.pendingSlots.shift();
                state.displayedQuestions[slot] = state.currentIndex;
                state.currentIndex++;
            }

            // Hide Next button
            nextBtn.classList.remove('show');

            renderQuestions();

            // Check if quiz is complete (all displayed questions answered)
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                setTimeout(showResults, 500);
            }
        }

        function updateStats() {
            const answered = Object.keys(state.answers).length;
            const total = quizData.questions.length;

            progressBar.style.width = `${(answered / total) * 100}%`;
            progressBadge.textContent = `${answered}/${total}`;
            scoreBadge.textContent = `Score: ${state.score}`;
        }

        function showResults() {
            questionsRow.style.display = 'none';
            nextBtn.classList.remove('show');
            resultsCard.classList.add('show');

            const total = quizData.questions.length;
            const percentage = Math.round((state.score / total) * 100);

            document.getElementById('resultsScore').textContent = `${state.score}/${total}`;

            let grade, gradeClass, icon;
            if (percentage >= 90) { grade = 'Excellent! A'; gradeClass = 'grade-a'; icon = '&#127942;'; }
            else if (percentage >= 80) { grade = 'Great! B'; gradeClass = 'grade-b'; icon = '&#11088;'; }
            else if (percentage >= 70) { grade = 'Good! C'; gradeClass = 'grade-c'; icon = '&#128077;'; }
            else if (percentage >= 60) { grade = 'Pass - D'; gradeClass = 'grade-d'; icon = '&#128221;'; }
            else { grade = 'Keep practicing'; gradeClass = 'grade-f'; icon = '&#128218;'; }

            document.getElementById('resultsIcon').innerHTML = icon;
            const gradeEl = document.getElementById('resultsGrade');
            gradeEl.textContent = `${grade} (${percentage}%)`;
            gradeEl.className = `results-grade ${gradeClass}`;
        }

        function restartQuiz() {
            initQuiz();
        }

        function renderMath() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initQuiz();
            setTimeout(renderMath, 100);
        });
    </script>
</body>
</html>
