<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 3.2: Blockchain Mechanics | Introduction to Digital Finance</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        :root {
            --mlpurple: #3333B2;
            --mlblue: #0066CC;
            --quiz-accent: #8b5cf6;
            --quiz-light: #ede9fe;
            --correct: #22c55e;
            --correct-bg: #dcfce7;
            --incorrect: #ef4444;
            --incorrect-bg: #fee2e2;
            --bg: #f6f8fa;
            --card-bg: #ffffff;
            --text: #24292e;
            --text-secondary: #586069;
            --border: #e1e4e8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.4;
            min-height: 100vh;
        }

        .nav {
            background: linear-gradient(135deg, var(--mlpurple), var(--mlblue));
            color: white;
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nav-title { font-weight: 600; font-size: 14px; }
        .nav-links { display: flex; gap: 16px; }
        .nav-links a { color: white; text-decoration: none; font-size: 12px; opacity: 0.9; }
        .nav-links a:hover { opacity: 1; }

        .quiz-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 12px;
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 4px;
        }
        .quiz-title { font-size: 16px; font-weight: 600; color: var(--mlpurple); }
        .quiz-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }
        .stat-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .stat-progress { background: var(--quiz-light); color: var(--quiz-accent); }
        .stat-score { background: var(--correct-bg); color: var(--correct); }

        .progress-bar-container {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-bottom: 12px;
        }
        .progress-bar {
            height: 100%;
            background: var(--quiz-accent);
            border-radius: 2px;
            transition: width 0.3s;
        }

        /* Three-column layout */
        .questions-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            min-height: 280px;
        }

        .question-card.answered { opacity: 0.7; }

        .question-card.correct-card {
            border: 2px solid var(--correct);
            background: linear-gradient(to bottom, var(--correct-bg), var(--card-bg));
        }

        .question-card.incorrect-card {
            border: 2px solid var(--incorrect);
            background: linear-gradient(to bottom, var(--incorrect-bg), var(--card-bg));
        }

        .q-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .q-number {
            background: var(--quiz-light);
            color: var(--quiz-accent);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .q-status { font-size: 14px; }

        .q-text {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 10px;
            line-height: 1.4;
            flex-grow: 0;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-grow: 1;
        }

        .option-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            min-height: 44px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            font-size: 12px;
        }

        .option-btn:hover:not(.disabled) {
            border-color: var(--quiz-accent);
            background: var(--quiz-light);
        }

        .option-btn.correct {
            border-color: var(--correct);
            background: var(--correct-bg);
        }

        .option-btn.incorrect {
            border-color: var(--incorrect);
            background: var(--incorrect-bg);
        }

        .option-btn.disabled { cursor: default; }

        .option-letter {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }

        .option-btn.correct .option-letter {
            background: var(--correct);
            color: white;
        }

        .option-btn.incorrect .option-letter {
            background: var(--incorrect);
            color: white;
        }

        .option-text { flex: 1; }

        .feedback {
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.4;
            display: none;
        }

        .feedback.show { display: block; }
        .feedback.correct { background: var(--correct-bg); color: #166534; }
        .feedback.incorrect { background: var(--incorrect-bg); color: #991b1b; }

        /* Results */
        .results-card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 32px;
            text-align: center;
            max-width: 500px;
            margin: 40px auto;
            display: none;
        }
        .results-card.show { display: block; }
        .results-icon { font-size: 48px; margin-bottom: 8px; }
        .results-score { font-size: 36px; font-weight: 700; color: var(--quiz-accent); }
        .results-label { font-size: 14px; color: var(--text-secondary); margin-bottom: 16px; }
        .results-grade {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .grade-a { background: #dcfce7; color: #166534; }
        .grade-b { background: #dbeafe; color: #1e40af; }
        .grade-c { background: #fef3c7; color: #92400e; }
        .grade-d { background: #fed7aa; color: #9a3412; }
        .grade-f { background: #fee2e2; color: #991b1b; }

        .results-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            text-decoration: none;
        }
        .btn-primary { background: var(--quiz-accent); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-secondary { background: var(--card-bg); color: var(--text); border: 1px solid var(--border); }

        /* Next button container */
        .next-btn-container {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        .btn-next {
            padding: 10px 32px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            background: var(--quiz-accent);
            color: white;
            transition: all 0.2s;
            display: none;
        }
        .btn-next:hover { background: #7c3aed; transform: scale(1.02); }
        .btn-next.show { display: inline-block; }
        .btn-next:disabled { opacity: 0.5; cursor: not-allowed; }

        @media (max-width: 900px) {
            .questions-row { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 600px) {
            .questions-row { grid-template-columns: 1fr; }
            .question-card { min-height: auto; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-title">Quiz 3.2: Blockchain Mechanics</div>
        <div class="nav-links">
            <a href="../index.html">Dashboard</a>
            
            <a href="https://github.com/Digital-AI-Finance/Digital-Finance-Introduction" target="_blank">GitHub</a>
        </div>
    </nav>

    <main class="quiz-container">
        <div class="quiz-header">
            <div class="quiz-title">Quiz 3.2: Blockchain Mechanics</div>
            <div class="quiz-stats">
                <span class="stat-badge stat-progress" id="progressBadge">0/20</span>
                <span class="stat-badge stat-score" id="scoreBadge">Score: 0</span>
            </div>
        </div>

        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>

        <div class="questions-row" id="questionsRow"></div>

        <div class="next-btn-container">
            <button class="btn-next" id="nextBtn" onclick="loadNextQuestions()">Next</button>
        </div>

        <div class="results-card" id="resultsCard">
            <div class="results-icon" id="resultsIcon"></div>
            <div class="results-score" id="resultsScore"></div>
            <div class="results-label">Correct Answers</div>
            <div class="results-grade" id="resultsGrade"></div>
            <div class="results-buttons">
                <button class="btn btn-primary" onclick="restartQuiz()">Try Again</button>
                <a href="../index.html" class="btn btn-secondary">Dashboard</a>
            </div>
        </div>
    </main>

    <script>
        const quizData = {
            questions: [
                {
                                "id": 1,
                                "question": "What is a blockchain?",
                                "options": {
                                                "A": "A single encrypted database stored on one server",
                                                "B": "A chain of blocks where each block is linked to the previous block by cryptographic hashes",
                                                "C": "A type of cryptocurrency wallet",
                                                "D": "A programming language for smart contracts"
                                },
                                "correct": "B",
                                "difficulty": "easy",
                                "explanation": "A blockchain is a chain of blocks where each block contains data and is cryptographically linked to the previous block through hashes. This creates an immutable chain where changing any block would break all subsequent links."
                },
                {
                                "id": 2,
                                "question": "Which of the following are components of a block's structure?",
                                "options": {
                                                "A": "Only the transaction data and timestamp",
                                                "B": "Index, timestamp, data, previous hash, nonce, and current hash",
                                                "C": "Only the cryptographic hash and signature",
                                                "D": "Public key, private key, and transaction list"
                                },
                                "correct": "B",
                                "difficulty": "easy",
                                "explanation": "A block contains multiple components: index (position in chain), timestamp (when created), data (transactions/content), previous hash (link to previous block), nonce (proof-of-work number), and hash (the block's digital fingerprint). All these components work together to create a secure, tamper-evident structure."
                },
                {
                                "id": 3,
                                "question": "What is the role of the 'previous hash' field in a block?",
                                "options": {
                                                "A": "It encrypts the transaction data",
                                                "B": "It creates the chain by linking the current block to the previous block's hash",
                                                "C": "It stores the miner's reward",
                                                "D": "It validates the current block's transactions"
                                },
                                "correct": "B",
                                "difficulty": "easy",
                                "explanation": "The 'previous hash' field contains the hash of the previous block, creating the 'chain' in blockchain. This linking mechanism means that if any block is changed, all subsequent blocks will have invalid previous hash references, making tampering immediately detectable."
                },
                {
                                "id": 4,
                                "question": "Why is blockchain considered immutable?",
                                "options": {
                                                "A": "Because data cannot be written to it after creation",
                                                "B": "Because changing any block requires recalculating all subsequent blocks, which is computationally prohibitive with proof-of-work",
                                                "C": "Because it uses military-grade encryption",
                                                "D": "Because only administrators can modify blocks"
                                },
                                "correct": "B",
                                "difficulty": "medium",
                                "explanation": "Blockchain immutability comes from the hash chain structure combined with proof-of-work. Changing any historical block breaks the chain for all subsequent blocks. To repair it, you'd need to recalculate (re-mine) every block after the change, which requires enormous computational resources, making tampering economically impractical."
                },
                {
                                "id": 5,
                                "question": "What is Proof-of-Work (PoW)?",
                                "options": {
                                                "A": "A document proving you own cryptocurrency",
                                                "B": "A consensus mechanism requiring computational work to find a hash meeting specific difficulty criteria",
                                                "C": "A certificate issued by blockchain validators",
                                                "D": "A method to encrypt blockchain data"
                                },
                                "correct": "B",
                                "difficulty": "easy",
                                "explanation": "Proof-of-Work is a consensus mechanism where miners must find a hash that meets specific difficulty requirements (e.g., starting with a certain number of zeros). This requires trying many different nonce values, making block creation computationally expensive and preventing spam or easy tampering."
                },
                {
                                "id": 6,
                                "question": "What is mining in the context of blockchain?",
                                "options": {
                                                "A": "Extracting cryptocurrency from the blockchain database",
                                                "B": "The process of finding a valid nonce that produces a hash meeting the difficulty target",
                                                "C": "Transferring coins between wallets",
                                                "D": "Verifying user identities on the network"
                                },
                                "correct": "B",
                                "difficulty": "easy",
                                "explanation": "Mining is the computational process of finding a valid block hash that meets the network's difficulty requirement. Miners repeatedly change the nonce value and calculate the block's hash until they find one that starts with the required number of zeros. This proof-of-work secures the blockchain by making block creation expensive."
                },
                {
                                "id": 7,
                                "question": "What is the purpose of the nonce in a block?",
                                "options": {
                                                "A": "To timestamp when the block was created",
                                                "B": "To encrypt the block's transactions",
                                                "C": "A number that miners change repeatedly to find a hash that meets the difficulty target",
                                                "D": "To store the miner's wallet address"
                                },
                                "correct": "C",
                                "difficulty": "medium",
                                "explanation": "The nonce (number used once) is a field that miners increment repeatedly during the mining process. Since changing any part of a block changes its hash, miners adjust the nonce to try different hash values until they find one meeting the difficulty requirement (e.g., starting with specific zeros)."
                },
                {
                                "id": 8,
                                "question": "How does difficulty target adjustment work in blockchain networks?",
                                "options": {
                                                "A": "It's fixed permanently when the blockchain is created",
                                                "B": "Miners vote on increasing or decreasing difficulty",
                                                "C": "The network automatically adjusts difficulty to maintain a target block time as hash power changes",
                                                "D": "Central administrators manually adjust it quarterly"
                                },
                                "correct": "C",
                                "difficulty": "medium",
                                "explanation": "Blockchain networks like Bitcoin automatically adjust mining difficulty to maintain consistent block times (Bitcoin targets ~10 minutes). If blocks are being mined too quickly (more hash power), difficulty increases. If too slowly (less hash power), difficulty decreases. This self-regulation maintains network stability."
                },
                {
                                "id": 9,
                                "question": "Describe the hash puzzle solving process in proof-of-work mining.",
                                "options": {
                                                "A": "Miners solve complex mathematical equations involving prime numbers",
                                                "B": "Miners repeatedly change the nonce and calculate the block hash until finding one that starts with the required number of zeros",
                                                "C": "Miners decrypt encrypted puzzles using private keys",
                                                "D": "Miners compete to find the shortest hash value"
                                },
                                "correct": "B",
                                "difficulty": "medium",
                                "explanation": "The hash puzzle is simple but computationally intensive: find a nonce that produces a hash meeting the difficulty target. Since hash functions are one-way and unpredictable, the only approach is brute force - incrementing the nonce and recalculating the hash until finding one with the required properties (e.g., starting with '000...')."
                },
                {
                                "id": 10,
                                "question": "Why is mining computationally expensive?",
                                "options": {
                                                "A": "Because each hash calculation requires solving complex algebraic equations",
                                                "B": "Because finding a hash meeting the difficulty target requires trying millions or billions of nonce values on average",
                                                "C": "Because miners must download the entire blockchain first",
                                                "D": "Because mining requires encrypting large amounts of data"
                                },
                                "correct": "B",
                                "difficulty": "medium",
                                "explanation": "Mining is expensive because hash functions produce unpredictable outputs. With a difficulty of 19 leading zeros (Bitcoin), the probability of any single hash being valid is approximately 1 in 16^19. This means miners must calculate trillions of hashes on average to find one valid block, consuming massive computational resources and electricity."
                },
                {
                                "id": 11,
                                "question": "What is the relationship between block time and difficulty in proof-of-work blockchains?",
                                "options": {
                                                "A": "They are unrelated - block time is random",
                                                "B": "Difficulty adjusts to maintain a target average block time as network hash power changes",
                                                "C": "Block time always increases as difficulty increases",
                                                "D": "Faster block times always mean lower difficulty"
                                },
                                "correct": "B",
                                "difficulty": "hard",
                                "explanation": "Block time and difficulty have an inverse relationship that's automatically regulated. When network hash power increases, blocks would be found faster, so difficulty increases to maintain the target block time. When hash power decreases, difficulty decreases. Bitcoin targets ~10 minutes per block and adjusts difficulty every 2016 blocks (~2 weeks)."
                },
                {
                                "id": 12,
                                "question": "What is the longest chain rule in blockchain?",
                                "options": {
                                                "A": "The blockchain with the most transactions is considered valid",
                                                "B": "Nodes accept the chain with the most cumulative proof-of-work (typically the longest) as the valid chain",
                                                "C": "Only chains longer than 100 blocks are valid",
                                                "D": "The first chain created is always the valid one"
                                },
                                "correct": "B",
                                "difficulty": "medium",
                                "explanation": "The longest chain rule (more precisely, the chain with most cumulative work) is the consensus mechanism in proof-of-work blockchains. When competing versions of the blockchain exist (e.g., temporary forks), nodes adopt the chain representing the most computational work, which is typically the longest chain. This rule provides decentralized consensus."
                },
                {
                                "id": 13,
                                "question": "What is a chain reorganization (reorg)?",
                                "options": {
                                                "A": "When nodes rearrange blocks chronologically",
                                                "B": "When a longer competing chain causes nodes to abandon their current chain tip and adopt the longer chain",
                                                "C": "When miners vote to change the blockchain protocol",
                                                "D": "When transactions are sorted by priority"
                                },
                                "correct": "B",
                                "difficulty": "hard",
                                "explanation": "A chain reorganization occurs when a node discovers a different chain with more cumulative proof-of-work than its current chain. The node then abandons recent blocks and adopts the longer chain. This can happen naturally with temporary forks when two miners find blocks simultaneously, or maliciously during a 51% attack. Reorgs deeper than 1-2 blocks are rare."
                },
                {
                                "id": 14,
                                "question": "What is a 51% attack and how does it work?",
                                "options": {
                                                "A": "When 51% of users agree to change the blockchain rules",
                                                "B": "When an attacker controls over 50% of network hash power and can reorganize the chain, double-spend, or censor transactions",
                                                "C": "When 51% of nodes go offline simultaneously",
                                                "D": "When transaction fees exceed 51% of block reward"
                                },
                                "correct": "B",
                                "difficulty": "hard",
                                "explanation": "A 51% attack occurs when an entity controls more than 50% of the network's hash power. This allows them to mine blocks faster than the rest of the network, enabling chain reorganizations to reverse their own transactions (double-spending) or censor others' transactions. However, they cannot steal coins or change consensus rules. The enormous cost of acquiring 51% hash power makes this attack economically prohibitive for major chains like Bitcoin."
                },
                {
                                "id": 15,
                                "question": "Why does confirmation depth matter for transaction security?",
                                "options": {
                                                "A": "Deeper confirmations make transactions process faster",
                                                "B": "Each additional block confirmation makes it exponentially more expensive to reverse a transaction via reorganization",
                                                "C": "Transactions in deeper blocks pay higher fees",
                                                "D": "Confirmation depth determines transaction priority"
                                },
                                "correct": "B",
                                "difficulty": "hard",
                                "explanation": "Confirmation depth (number of blocks after a transaction) directly relates to security. To reverse a transaction with 6 confirmations, an attacker must re-mine 6 blocks faster than the network - extremely expensive. Each additional confirmation exponentially increases the computational cost of reversal. Bitcoin commonly considers 6 confirmations (~1 hour) secure for large transactions."
                },
                {
                                "id": 16,
                                "question": "What is the genesis block?",
                                "options": {
                                                "A": "The most recent block in the blockchain",
                                                "B": "The first block in a blockchain, with no previous block to reference",
                                                "C": "A block that creates new cryptocurrency",
                                                "D": "The largest block in terms of data size"
                                },
                                "correct": "B",
                                "difficulty": "easy",
                                "explanation": "The genesis block (Block 0) is the first block in any blockchain and has no previous block to reference. Bitcoin's genesis block was mined on January 3, 2009, and contains the message: 'The Times 03/Jan/2009 Chancellor on brink of second bailout for banks' - proving it wasn't created earlier and making a political statement."
                },
                {
                                "id": 17,
                                "question": "What role does a Merkle tree play in block structure?",
                                "options": {
                                                "A": "It encrypts all transactions in a block",
                                                "B": "It creates a hierarchical hash structure allowing efficient verification of transaction inclusion without downloading all transactions",
                                                "C": "It stores backup copies of transactions",
                                                "D": "It determines transaction ordering in the block"
                                },
                                "correct": "B",
                                "difficulty": "hard",
                                "explanation": "A Merkle tree is a binary hash tree where transactions are hashed in pairs recursively until reaching a single root hash (Merkle root) stored in the block header. This structure allows light nodes to verify a specific transaction is included in a block using only O(log n) hashes (the Merkle proof) rather than downloading all transactions - critical for scalability."
                },
                {
                                "id": 18,
                                "question": "How does block propagation work in a blockchain network?",
                                "options": {
                                                "A": "All blocks are sent to a central server first, then distributed",
                                                "B": "When a miner finds a valid block, they broadcast it peer-to-peer to connected nodes, who validate and relay it to their peers",
                                                "C": "Blocks are only shared between mining pools",
                                                "D": "Blocks propagate through email notifications"
                                },
                                "correct": "B",
                                "difficulty": "medium",
                                "explanation": "Block propagation is decentralized and peer-to-peer. When a miner finds a valid block, they immediately broadcast it to their connected peers. Each receiving node validates the block (checking hash, difficulty, transactions) and, if valid, relays it to their peers. This gossip protocol propagates blocks across the entire network in seconds, though network latency can cause temporary forks."
                },
                {
                                "id": 19,
                                "question": "What is the difference between full nodes and light nodes?",
                                "options": {
                                                "A": "Full nodes mine blocks, light nodes only validate them",
                                                "B": "Full nodes store and validate the entire blockchain, while light nodes only store block headers and use SPV to verify transactions",
                                                "C": "Full nodes are faster than light nodes",
                                                "D": "Light nodes are only used for testing blockchains"
                                },
                                "correct": "B",
                                "difficulty": "hard",
                                "explanation": "Full nodes download and validate the entire blockchain (hundreds of GB for Bitcoin), independently verifying all transactions and blocks according to consensus rules. Light nodes (SPV - Simplified Payment Verification) only download block headers (~80 bytes each) and request Merkle proofs for relevant transactions. Light nodes trust the longest chain and mining difficulty but don't independently validate all transactions, trading security for efficiency."
                },
                {
                                "id": 20,
                                "question": "Why is energy consumption a concern for proof-of-work blockchains, and what are alternatives?",
                                "options": {
                                                "A": "Energy isn't a concern - mining uses renewable energy exclusively",
                                                "B": "PoW mining consumes ~138 TWh/year (Bitcoin) due to computational competition; alternatives like Proof-of-Stake replace computation with economic stake",
                                                "C": "Energy consumption only matters for small blockchains",
                                                "D": "There are no viable alternatives to proof-of-work"
                                },
                                "correct": "B",
                                "difficulty": "medium",
                                "explanation": "Bitcoin's PoW mining consumes approximately 138 TWh annually (comparable to some countries) because security relies on making attacks computationally expensive. This has environmental concerns. Alternatives include: Proof-of-Stake (Ethereum 2.0) where validators stake coins rather than compute, Proof-of-Authority for private chains, and hybrid approaches. These reduce energy ~99% but involve different security trade-offs and trust assumptions."
                }
]
        };

        const state = {
            currentIndex: 0,
            answers: {},
            score: 0,
            displayedQuestions: [],
            pendingSlots: []
        };

        const questionsRow = document.getElementById('questionsRow');
        const progressBar = document.getElementById('progressBar');
        const progressBadge = document.getElementById('progressBadge');
        const scoreBadge = document.getElementById('scoreBadge');
        const resultsCard = document.getElementById('resultsCard');
        const nextBtn = document.getElementById('nextBtn');

        function initQuiz() {
            state.currentIndex = 0;
            state.answers = {};
            state.score = 0;
            state.displayedQuestions = [];
            state.pendingSlots = [];

            resultsCard.classList.remove('show');
            questionsRow.style.display = 'grid';
            nextBtn.classList.remove('show');

            // Show first 3 questions
            for (let i = 0; i < 3 && i < quizData.questions.length; i++) {
                state.displayedQuestions.push(i);
            }
            state.currentIndex = Math.min(3, quizData.questions.length);

            renderQuestions();
            updateStats();
        }

        function renderQuestions() {
            questionsRow.innerHTML = '';

            state.displayedQuestions.forEach((qIdx, slot) => {
                const q = quizData.questions[qIdx];
                const answered = state.answers[q.id] !== undefined;
                const isCorrect = answered && state.answers[q.id] === q.correct;
                const isIncorrect = answered && state.answers[q.id] !== q.correct;

                const card = document.createElement('div');
                card.className = 'question-card';
                if (isCorrect) card.classList.add('correct-card', 'answered');
                if (isIncorrect) card.classList.add('incorrect-card', 'answered');

                card.innerHTML = `
                    <div class="q-header">
                        <span class="q-number">Q${qIdx + 1}</span>
                        ${answered ? `<span class="q-status">${isCorrect ? '&#10004;' : '&#10008;'}</span>` : ''}
                    </div>
                    <div class="q-text">${q.question}</div>
                    <div class="options" data-qid="${q.id}" data-slot="${slot}">
                        ${['A','B','C','D'].map(letter => {
                            let optClass = 'option-btn';
                            if (answered) {
                                optClass += ' disabled';
                                if (letter === q.correct) optClass += ' correct';
                                else if (letter === state.answers[q.id]) optClass += ' incorrect';
                            }
                            return `
                                <button class="${optClass}" data-letter="${letter}" ${answered ? 'disabled' : ''}>
                                    <span class="option-letter">${letter}</span>
                                    <span class="option-text">${q.options[letter]}</span>
                                </button>
                            `;
                        }).join('')}
                    </div>
                    <div class="feedback ${answered ? 'show' : ''} ${isCorrect ? 'correct' : 'incorrect'}">
                        ${answered ? (isCorrect ? '&#10004; ' : `&#10008; Answer: ${q.correct}. `) + q.explanation : ''}
                    </div>
                `;

                // Add click handlers
                if (!answered) {
                    card.querySelectorAll('.option-btn').forEach(btn => {
                        btn.addEventListener('click', () => handleAnswer(qIdx, slot, btn.dataset.letter));
                    });
                }

                questionsRow.appendChild(card);
            });

            renderMath();
        }

        function handleAnswer(qIdx, slot, letter) {
            const q = quizData.questions[qIdx];
            state.answers[q.id] = letter;

            if (letter === q.correct) state.score++;

            // Track this slot as pending replacement
            if (!state.pendingSlots.includes(slot)) {
                state.pendingSlots.push(slot);
            }

            updateStats();
            renderQuestions();

            // Check if all questions answered
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                // Short delay then show results
                setTimeout(showResults, 800);
            } else if (state.currentIndex < quizData.questions.length && state.pendingSlots.length > 0) {
                // Show Next button if there are more questions and pending slots
                nextBtn.classList.add('show');
            }
        }

        function loadNextQuestions() {
            // Replace pending slots with new questions
            while (state.pendingSlots.length > 0 && state.currentIndex < quizData.questions.length) {
                const slot = state.pendingSlots.shift();
                state.displayedQuestions[slot] = state.currentIndex;
                state.currentIndex++;
            }

            // Hide Next button
            nextBtn.classList.remove('show');

            renderQuestions();

            // Check if quiz is complete (all displayed questions answered)
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                setTimeout(showResults, 500);
            }
        }

        function updateStats() {
            const answered = Object.keys(state.answers).length;
            const total = quizData.questions.length;

            progressBar.style.width = `${(answered / total) * 100}%`;
            progressBadge.textContent = `${answered}/${total}`;
            scoreBadge.textContent = `Score: ${state.score}`;
        }

        function showResults() {
            questionsRow.style.display = 'none';
            nextBtn.classList.remove('show');
            resultsCard.classList.add('show');

            const total = quizData.questions.length;
            const percentage = Math.round((state.score / total) * 100);

            document.getElementById('resultsScore').textContent = `${state.score}/${total}`;

            let grade, gradeClass, icon;
            if (percentage >= 90) { grade = 'Excellent! A'; gradeClass = 'grade-a'; icon = '&#127942;'; }
            else if (percentage >= 80) { grade = 'Great! B'; gradeClass = 'grade-b'; icon = '&#11088;'; }
            else if (percentage >= 70) { grade = 'Good! C'; gradeClass = 'grade-c'; icon = '&#128077;'; }
            else if (percentage >= 60) { grade = 'Pass - D'; gradeClass = 'grade-d'; icon = '&#128221;'; }
            else { grade = 'Keep practicing'; gradeClass = 'grade-f'; icon = '&#128218;'; }

            document.getElementById('resultsIcon').innerHTML = icon;
            const gradeEl = document.getElementById('resultsGrade');
            gradeEl.textContent = `${grade} (${percentage}%)`;
            gradeEl.className = `results-grade ${gradeClass}`;
        }

        function restartQuiz() {
            initQuiz();
        }

        function renderMath() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initQuiz();
            setTimeout(renderMath, 100);
        });
    </script>
</body>
</html>
