<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 3.1: Cryptographic Blocks | Introduction to Digital Finance</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        :root {
            --mlpurple: #3333B2;
            --mlblue: #0066CC;
            --quiz-accent: #8b5cf6;
            --quiz-light: #ede9fe;
            --correct: #22c55e;
            --correct-bg: #dcfce7;
            --incorrect: #ef4444;
            --incorrect-bg: #fee2e2;
            --bg: #f6f8fa;
            --card-bg: #ffffff;
            --text: #24292e;
            --text-secondary: #586069;
            --border: #e1e4e8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.4;
            min-height: 100vh;
        }

        .nav {
            background: linear-gradient(135deg, var(--mlpurple), var(--mlblue));
            color: white;
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nav-title { font-weight: 600; font-size: 14px; }
        .nav-links { display: flex; gap: 16px; }
        .nav-links a { color: white; text-decoration: none; font-size: 12px; opacity: 0.9; }
        .nav-links a:hover { opacity: 1; }

        .quiz-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 12px;
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 4px;
        }
        .quiz-title { font-size: 16px; font-weight: 600; color: var(--mlpurple); }
        .quiz-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }
        .stat-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .stat-progress { background: var(--quiz-light); color: var(--quiz-accent); }
        .stat-score { background: var(--correct-bg); color: var(--correct); }

        .progress-bar-container {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-bottom: 12px;
        }
        .progress-bar {
            height: 100%;
            background: var(--quiz-accent);
            border-radius: 2px;
            transition: width 0.3s;
        }

        /* Three-column layout */
        .questions-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            min-height: 280px;
        }

        .question-card.answered { opacity: 0.7; }

        .question-card.correct-card {
            border: 2px solid var(--correct);
            background: linear-gradient(to bottom, var(--correct-bg), var(--card-bg));
        }

        .question-card.incorrect-card {
            border: 2px solid var(--incorrect);
            background: linear-gradient(to bottom, var(--incorrect-bg), var(--card-bg));
        }

        .q-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .q-number {
            background: var(--quiz-light);
            color: var(--quiz-accent);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .q-status { font-size: 14px; }

        .q-text {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 10px;
            line-height: 1.4;
            flex-grow: 0;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-grow: 1;
        }

        .option-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            min-height: 44px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            font-size: 12px;
        }

        .option-btn:hover:not(.disabled) {
            border-color: var(--quiz-accent);
            background: var(--quiz-light);
        }

        .option-btn.correct {
            border-color: var(--correct);
            background: var(--correct-bg);
        }

        .option-btn.incorrect {
            border-color: var(--incorrect);
            background: var(--incorrect-bg);
        }

        .option-btn.disabled { cursor: default; }

        .option-letter {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }

        .option-btn.correct .option-letter {
            background: var(--correct);
            color: white;
        }

        .option-btn.incorrect .option-letter {
            background: var(--incorrect);
            color: white;
        }

        .option-text { flex: 1; }

        .feedback {
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.4;
            display: none;
        }

        .feedback.show { display: block; }
        .feedback.correct { background: var(--correct-bg); color: #166534; }
        .feedback.incorrect { background: var(--incorrect-bg); color: #991b1b; }

        /* Results */
        .results-card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 32px;
            text-align: center;
            max-width: 500px;
            margin: 40px auto;
            display: none;
        }
        .results-card.show { display: block; }
        .results-icon { font-size: 48px; margin-bottom: 8px; }
        .results-score { font-size: 36px; font-weight: 700; color: var(--quiz-accent); }
        .results-label { font-size: 14px; color: var(--text-secondary); margin-bottom: 16px; }
        .results-grade {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .grade-a { background: #dcfce7; color: #166534; }
        .grade-b { background: #dbeafe; color: #1e40af; }
        .grade-c { background: #fef3c7; color: #92400e; }
        .grade-d { background: #fed7aa; color: #9a3412; }
        .grade-f { background: #fee2e2; color: #991b1b; }

        .results-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            text-decoration: none;
        }
        .btn-primary { background: var(--quiz-accent); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-secondary { background: var(--card-bg); color: var(--text); border: 1px solid var(--border); }

        /* Next button container */
        .next-btn-container {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        .btn-next {
            padding: 10px 32px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            background: var(--quiz-accent);
            color: white;
            transition: all 0.2s;
            display: none;
        }
        .btn-next:hover { background: #7c3aed; transform: scale(1.02); }
        .btn-next.show { display: inline-block; }
        .btn-next:disabled { opacity: 0.5; cursor: not-allowed; }

        @media (max-width: 900px) {
            .questions-row { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 600px) {
            .questions-row { grid-template-columns: 1fr; }
            .question-card { min-height: auto; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-title">Quiz 3.1: Cryptographic Blocks</div>
        <div class="nav-links">
            <a href="../index.html">Dashboard</a>
            
            <a href="https://github.com/Digital-AI-Finance/Digital-Finance-Introduction" target="_blank">GitHub</a>
        </div>
    </nav>

    <main class="quiz-container">
        <div class="quiz-header">
            <div class="quiz-title">Quiz 3.1: Cryptographic Blocks</div>
            <div class="quiz-stats">
                <span class="stat-badge stat-progress" id="progressBadge">0/20</span>
                <span class="stat-badge stat-score" id="scoreBadge">Score: 0</span>
            </div>
        </div>

        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>

        <div class="questions-row" id="questionsRow"></div>

        <div class="next-btn-container">
            <button class="btn-next" id="nextBtn" onclick="loadNextQuestions()">Next</button>
        </div>

        <div class="results-card" id="resultsCard">
            <div class="results-icon" id="resultsIcon"></div>
            <div class="results-score" id="resultsScore"></div>
            <div class="results-label">Correct Answers</div>
            <div class="results-grade" id="resultsGrade"></div>
            <div class="results-buttons">
                <button class="btn btn-primary" onclick="restartQuiz()">Try Again</button>
                <a href="../index.html" class="btn btn-secondary">Dashboard</a>
            </div>
        </div>
    </main>

    <script>
        const quizData = {
            questions: [
                {
                                "id": 1,
                                "question": "What is the primary purpose of a cryptographic hash function?",
                                "options": {
                                                "A": "To encrypt data so it can be decrypted later",
                                                "B": "To create a fixed-size unique fingerprint of any input data",
                                                "C": "To generate random numbers for cryptographic operations",
                                                "D": "To compress large files into smaller ones"
                                },
                                "correct": "B",
                                "explanation": "A cryptographic hash function takes any input (of any size) and produces a fixed-size output called a hash or digest. This serves as a unique 'fingerprint' of the data. Unlike encryption, hashing is one-way and cannot be reversed. The hash is not meant to compress data or generate random numbers, but to create a deterministic, unique identifier.",
                                "difficulty": "easy"
                },
                {
                                "id": 2,
                                "question": "Which property ensures that the same input to a hash function will always produce the same output?",
                                "options": {
                                                "A": "Collision resistance",
                                                "B": "Avalanche effect",
                                                "C": "Deterministic",
                                                "D": "One-way function"
                                },
                                "correct": "C",
                                "explanation": "The deterministic property means that a hash function will always produce the same output for the same input. This is essential for verification - if you hash 'Bitcoin' with SHA-256 today, you'll get the same hash tomorrow. Collision resistance prevents different inputs from having the same hash, the avalanche effect means small changes cause big output differences, and one-way means you can't reverse the hash.",
                                "difficulty": "easy"
                },
                {
                                "id": 3,
                                "question": "What is the output size of a SHA-256 hash function?",
                                "options": {
                                                "A": "128 bits (32 hexadecimal characters)",
                                                "B": "256 bits (64 hexadecimal characters)",
                                                "C": "512 bits (128 hexadecimal characters)",
                                                "D": "Variable size depending on input length"
                                },
                                "correct": "B",
                                "explanation": "SHA-256 always produces a 256-bit output, regardless of input size. Since each hexadecimal character represents 4 bits, a 256-bit hash is displayed as 64 hexadecimal characters. This fixed-size property is crucial - whether you hash a single letter or an entire book, you always get exactly 256 bits (64 hex characters) as output.",
                                "difficulty": "easy"
                },
                {
                                "id": 4,
                                "question": "What is the 'avalanche effect' in cryptographic hash functions?",
                                "options": {
                                                "A": "The hash function becomes faster when processing larger files",
                                                "B": "A small change in input produces a drastically different output",
                                                "C": "The function cascades errors to prevent tampering",
                                                "D": "Multiple hash functions are applied in sequence"
                                },
                                "correct": "B",
                                "explanation": "The avalanche effect means that even a tiny change in the input (changing one bit or character) will produce a completely different hash output - typically changing about 50% of the output bits. In the notebook, changing 'Finance!' to 'Finance?' changed nearly half of the 64 hexadecimal characters. This property makes it impossible to predict how input modifications affect the output, which is crucial for security.",
                                "difficulty": "medium"
                },
                {
                                "id": 5,
                                "question": "Which of the following best describes the relationship between public and private keys in asymmetric cryptography?",
                                "options": {
                                                "A": "They are identical copies of each other",
                                                "B": "They are mathematically related; the public key is derived from the private key",
                                                "C": "They are randomly generated and have no mathematical relationship",
                                                "D": "The private key is derived from the public key through hashing"
                                },
                                "correct": "B",
                                "explanation": "In public-key cryptography, the public and private keys are mathematically related - the public key is derived from the private key. However, this relationship is one-way: you cannot derive the private key from the public key (this is based on hard mathematical problems like factoring large numbers). The notebook demonstrated generating a private key first, then deriving the public key from it.",
                                "difficulty": "medium"
                },
                {
                                "id": 6,
                                "question": "What is the fundamental concept behind asymmetric (public-key) cryptography?",
                                "options": {
                                                "A": "The same key is used for both encryption and decryption",
                                                "B": "Two mathematically related keys where one encrypts/signs and the other decrypts/verifies",
                                                "C": "Keys are symmetric but stored in different locations",
                                                "D": "Multiple users share a single key for all operations"
                                },
                                "correct": "B",
                                "explanation": "Asymmetric cryptography uses a pair of mathematically related keys with complementary functions. What one key encrypts, only the other can decrypt. In blockchain: you sign with your private key and others verify with your public key. This is fundamentally different from symmetric encryption where the same key is used for both operations.",
                                "difficulty": "easy"
                },
                {
                                "id": 7,
                                "question": "What three properties does a digital signature provide?",
                                "options": {
                                                "A": "Encryption, compression, and speed",
                                                "B": "Authentication, integrity, and non-repudiation",
                                                "C": "Confidentiality, availability, and scalability",
                                                "D": "Hashing, signing, and verification"
                                },
                                "correct": "B",
                                "explanation": "A digital signature provides three critical security properties: (1) Authentication - proves the message was signed by the holder of the private key, (2) Integrity - proves the message hasn't been tampered with, and (3) Non-repudiation - the signer cannot deny having signed it. These properties are essential for blockchain transactions where you need to prove who authorized a transfer and that the amount hasn't been changed.",
                                "difficulty": "medium"
                },
                {
                                "id": 8,
                                "question": "What is the correct process for creating a digital signature?",
                                "options": {
                                                "A": "Encrypt the entire message with the public key",
                                                "B": "Hash the message, then encrypt the hash with the private key",
                                                "C": "Encrypt the message with the private key, then hash the result",
                                                "D": "Hash the message with the public key"
                                },
                                "correct": "B",
                                "explanation": "The signature creation process has two steps: (1) Hash the message using a cryptographic hash function like SHA-256, and (2) Encrypt the hash with your private key - this encrypted hash is the signature. We hash first because messages can be large, but hashes are always fixed-size (256 bits for SHA-256), making the signature process more efficient. The notebook demonstrated this with the RSA signature creation.",
                                "difficulty": "medium"
                },
                {
                                "id": 9,
                                "question": "How is a digital signature verified?",
                                "options": {
                                                "A": "Hash the received message and compare it directly to the signature",
                                                "B": "Decrypt the signature using the sender's public key and compare the result to a fresh hash of the message",
                                                "C": "Encrypt the message with the public key and check if it matches the signature",
                                                "D": "Use the private key to decrypt the signature and retrieve the original message"
                                },
                                "correct": "B",
                                "explanation": "To verify a signature: (1) Decrypt the signature using the sender's public key, which reveals the hash that was encrypted, (2) Independently hash the received message using the same hash function, (3) Compare the two hashes - if they match, the signature is valid. This proves both that the correct private key signed it (authentication) and that the message wasn't modified (integrity). The notebook showed this verification process succeeding with the correct key and failing with wrong keys or tampered messages.",
                                "difficulty": "medium"
                },
                {
                                "id": 10,
                                "question": "What happens when you try to verify a signature with the wrong public key?",
                                "options": {
                                                "A": "The verification succeeds but with a warning message",
                                                "B": "The signature is decrypted incorrectly and verification fails",
                                                "C": "The system automatically tries other public keys",
                                                "D": "The message is corrupted and becomes unreadable"
                                },
                                "correct": "B",
                                "explanation": "When verifying with the wrong public key, the decryption of the signature produces gibberish (not the correct hash), so when compared to the fresh hash of the message, they don't match and verification fails. The notebook demonstrated this by generating a different key pair and showing that verification failed with the wrong public key. This proves the signature was created by a specific private key - you can't fake it with a different key pair.",
                                "difficulty": "easy"
                },
                {
                                "id": 11,
                                "question": "How is a wallet address derived from a public key in blockchain systems?",
                                "options": {
                                                "A": "The public key is used directly as the wallet address",
                                                "B": "The public key is hashed, and the last 20 bytes form the address",
                                                "C": "The private key is hashed to create the address",
                                                "D": "Random generation independent of the key pair"
                                },
                                "correct": "B",
                                "explanation": "A wallet address is derived by hashing the public key (Ethereum uses Keccak-256, Bitcoin uses SHA-256 + RIPEMD-160) and taking a portion of the hash - typically the last 20 bytes. The notebook demonstrated this simplified process. This derivation means your address is cryptographically linked to your public key, which is linked to your private key, creating a chain of cryptographic proof. Anyone can see your address, but only you know the private key that controls it.",
                                "difficulty": "medium"
                },
                {
                                "id": 12,
                                "question": "In a blockchain transaction signing flow, what information is typically included before signing?",
                                "options": {
                                                "A": "Only the recipient's address",
                                                "B": "Sender address, recipient address, amount, nonce, and timestamp",
                                                "C": "Only the transaction amount and signature",
                                                "D": "The private key and public key"
                                },
                                "correct": "B",
                                "explanation": "A complete blockchain transaction includes multiple fields: from (sender address), to (recipient address), amount, nonce (transaction counter to prevent replay attacks), and timestamp. All these fields are serialized into a string and then signed. The notebook showed this exact structure. If any field changes after signing (like trying to increase the amount), the signature verification will fail. The keys themselves are never included in the transaction data.",
                                "difficulty": "medium"
                },
                {
                                "id": 13,
                                "question": "SHA-256 can produce $2^{256}$ possible hashes. What does this number represent in terms of security?",
                                "options": {
                                                "A": "About $10^{24}$ possibilities, similar to grains of sand on Earth",
                                                "B": "About $10^{77}$ possibilities, approaching the number of atoms in the universe",
                                                "C": "About $10^{12}$ possibilities, easily crackable with modern computers",
                                                "D": "About $10^{128}$ possibilities, more than the number of atoms in the universe"
                                },
                                "correct": "B",
                                "explanation": "The value $2^{256}$ is approximately $10^{77}$, which approaches the estimated number of atoms in the observable universe ($10^{80}$). The notebook explicitly calculated this comparison. This enormous number means finding a collision by brute force would take longer than the age of the universe, even using all computers on Earth. This is why SHA-256 is considered cryptographically secure for blockchain applications.",
                                "difficulty": "hard"
                },
                {
                                "id": 14,
                                "question": "What is the 'birthday attack' in the context of hash functions, and why does it reduce collision security?",
                                "options": {
                                                "A": "An attack that occurs on the anniversary of the blockchain's creation",
                                                "B": "Finding a collision requires only $2^{128}$ attempts for SHA-256 instead of $2^{256}$ due to probability theory",
                                                "C": "A timing attack that exploits hash function computation speed",
                                                "D": "An attack that reverses the hash by trying all possible birthdays"
                                },
                                "correct": "B",
                                "explanation": "The birthday attack is based on the birthday paradox from probability theory: you don't need to try all $2^{256}$ possibilities to find a collision, only about $2^{128}$ (the square root). This is because you're looking for any two inputs that match, not a specific target. However, even $2^{128}$ is still astronomically large and computationally infeasible, so SHA-256 remains secure. This is why the 256-bit output provides about 128 bits of collision security.",
                                "difficulty": "hard"
                },
                {
                                "id": 15,
                                "question": "Why are hash functions used extensively in blockchain systems?",
                                "options": {
                                                "A": "To encrypt all transaction data for privacy",
                                                "B": "To link blocks together, create transaction IDs, build Merkle trees, and enable proof-of-work",
                                                "C": "To generate private keys from public keys",
                                                "D": "To compress blockchain data for efficient storage"
                                },
                                "correct": "B",
                                "explanation": "The notebook listed four key uses of hash functions in blockchain: (1) Link blocks together in the chain (each block includes the hash of the previous block), (2) Create transaction IDs (each transaction is identified by its hash), (3) Merkle trees for efficient verification of large datasets, and (4) Proof-of-work mining (finding hashes below a target value). Hashing is not used for encryption or key generation, and it's not for compression.",
                                "difficulty": "medium"
                },
                {
                                "id": 16,
                                "question": "What is the primary difference between ECDSA and RSA in blockchain applications?",
                                "options": {
                                                "A": "ECDSA uses elliptic curves and provides equivalent security with smaller keys than RSA",
                                                "B": "RSA is faster than ECDSA for signature verification",
                                                "C": "ECDSA can only be used for encryption, not signatures",
                                                "D": "RSA is more secure because it uses larger keys"
                                },
                                "correct": "A",
                                "explanation": "ECDSA (Elliptic Curve Digital Signature Algorithm) uses elliptic curve mathematics and provides equivalent security to RSA with much smaller key sizes. A 256-bit ECDSA key provides security comparable to a 3072-bit RSA key. Bitcoin and Ethereum use ECDSA because smaller keys mean smaller transactions and signatures, saving blockchain space. The notebook used RSA for demonstration simplicity, but noted that real blockchains use ECDSA.",
                                "difficulty": "hard"
                },
                {
                                "id": 17,
                                "question": "What is secp256k1, and why is it significant in cryptocurrency?",
                                "options": {
                                                "A": "A specific SHA-256 variant used only for mining",
                                                "B": "The elliptic curve specification used by Bitcoin and Ethereum for ECDSA",
                                                "C": "A consensus algorithm for blockchain networks",
                                                "D": "A wallet address format standard"
                                },
                                "correct": "B",
                                "explanation": "secp256k1 is the specific elliptic curve used by Bitcoin, Ethereum, and many other cryptocurrencies for their ECDSA signatures. It's defined by specific mathematical parameters and provides 256-bit security. The 'sec' stands for Standards for Efficient Cryptography, 'p256' indicates it's a 256-bit curve, and 'k1' indicates specific curve constants. While the notebook used RSA for simplicity, production blockchains use secp256k1 ECDSA.",
                                "difficulty": "hard"
                },
                {
                                "id": 18,
                                "question": "What does 'preimage resistance' mean for a hash function?",
                                "options": {
                                                "A": "The hash output always has the same size regardless of input",
                                                "B": "Given a hash output, it's computationally infeasible to find any input that produces that hash",
                                                "C": "The hash function prevents images from being stored in the blockchain",
                                                "D": "Two different inputs cannot produce the same hash"
                                },
                                "correct": "B",
                                "explanation": "Preimage resistance means the hash function is a one-way function - given a hash output, you cannot reverse it to find the input that produced it. This is one of the five key properties of cryptographic hash functions mentioned in the notebook. It's different from collision resistance (option D), which prevents finding two different inputs with the same output. Preimage resistance is essential for blockchain security - if you could reverse hashes, you could potentially forge signatures or break mining.",
                                "difficulty": "hard"
                },
                {
                                "id": 19,
                                "question": "What is the key distinction between signing a message and encrypting it?",
                                "options": {
                                                "A": "Signing uses the private key to prove authorship; encryption uses the public key to hide content",
                                                "B": "Signing and encryption are the same operation with different names",
                                                "C": "Signing uses the public key; encryption uses the private key",
                                                "D": "Signing is reversible; encryption is one-way like hashing"
                                },
                                "correct": "A",
                                "explanation": "Signing and encryption serve different purposes: Signing uses your private key to prove you authorized something (authentication), and anyone with your public key can verify it. Encryption uses the recipient's public key to hide content so only they can read it with their private key (confidentiality). In blockchain, transactions are signed (to prove authorization) but not encrypted (they're publicly visible). The notebook demonstrated signing for authentication, not encryption for privacy.",
                                "difficulty": "medium"
                },
                {
                                "id": 20,
                                "question": "What are the best practices for storing private keys in cryptocurrency wallets?",
                                "options": {
                                                "A": "Store them in a text file on your computer for easy access",
                                                "B": "Email them to yourself for backup",
                                                "C": "Use hardware wallets or write down seed phrases and store them securely offline",
                                                "D": "Upload them to cloud storage with password protection"
                                },
                                "correct": "C",
                                "explanation": "The safest methods for storing private keys are: (1) Hardware wallets - dedicated devices that keep keys offline and sign transactions internally, or (2) Seed phrases (12-24 words) written down and stored securely offline (like in a safe). These methods protect against hacking, malware, and theft. Storing keys in text files, emails, or cloud storage exposes them to theft. The notebook emphasized that 'Private key = secret' and controls your funds, so security is paramount. If someone gets your private key, they control your cryptocurrency.",
                                "difficulty": "easy"
                }
]
        };

        const state = {
            currentIndex: 0,
            answers: {},
            score: 0,
            displayedQuestions: [],
            pendingSlots: []
        };

        const questionsRow = document.getElementById('questionsRow');
        const progressBar = document.getElementById('progressBar');
        const progressBadge = document.getElementById('progressBadge');
        const scoreBadge = document.getElementById('scoreBadge');
        const resultsCard = document.getElementById('resultsCard');
        const nextBtn = document.getElementById('nextBtn');

        function initQuiz() {
            state.currentIndex = 0;
            state.answers = {};
            state.score = 0;
            state.displayedQuestions = [];
            state.pendingSlots = [];

            resultsCard.classList.remove('show');
            questionsRow.style.display = 'grid';
            nextBtn.classList.remove('show');

            // Show first 3 questions
            for (let i = 0; i < 3 && i < quizData.questions.length; i++) {
                state.displayedQuestions.push(i);
            }
            state.currentIndex = Math.min(3, quizData.questions.length);

            renderQuestions();
            updateStats();
        }

        function renderQuestions() {
            questionsRow.innerHTML = '';

            state.displayedQuestions.forEach((qIdx, slot) => {
                const q = quizData.questions[qIdx];
                const answered = state.answers[q.id] !== undefined;
                const isCorrect = answered && state.answers[q.id] === q.correct;
                const isIncorrect = answered && state.answers[q.id] !== q.correct;

                const card = document.createElement('div');
                card.className = 'question-card';
                if (isCorrect) card.classList.add('correct-card', 'answered');
                if (isIncorrect) card.classList.add('incorrect-card', 'answered');

                card.innerHTML = `
                    <div class="q-header">
                        <span class="q-number">Q${qIdx + 1}</span>
                        ${answered ? `<span class="q-status">${isCorrect ? '&#10004;' : '&#10008;'}</span>` : ''}
                    </div>
                    <div class="q-text">${q.question}</div>
                    <div class="options" data-qid="${q.id}" data-slot="${slot}">
                        ${['A','B','C','D'].map(letter => {
                            let optClass = 'option-btn';
                            if (answered) {
                                optClass += ' disabled';
                                if (letter === q.correct) optClass += ' correct';
                                else if (letter === state.answers[q.id]) optClass += ' incorrect';
                            }
                            return `
                                <button class="${optClass}" data-letter="${letter}" ${answered ? 'disabled' : ''}>
                                    <span class="option-letter">${letter}</span>
                                    <span class="option-text">${q.options[letter]}</span>
                                </button>
                            `;
                        }).join('')}
                    </div>
                    <div class="feedback ${answered ? 'show' : ''} ${isCorrect ? 'correct' : 'incorrect'}">
                        ${answered ? (isCorrect ? '&#10004; ' : `&#10008; Answer: ${q.correct}. `) + q.explanation : ''}
                    </div>
                `;

                // Add click handlers
                if (!answered) {
                    card.querySelectorAll('.option-btn').forEach(btn => {
                        btn.addEventListener('click', () => handleAnswer(qIdx, slot, btn.dataset.letter));
                    });
                }

                questionsRow.appendChild(card);
            });

            renderMath();
        }

        function handleAnswer(qIdx, slot, letter) {
            const q = quizData.questions[qIdx];
            state.answers[q.id] = letter;

            if (letter === q.correct) state.score++;

            // Track this slot as pending replacement
            if (!state.pendingSlots.includes(slot)) {
                state.pendingSlots.push(slot);
            }

            updateStats();
            renderQuestions();

            // Check if all questions answered
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                // Short delay then show results
                setTimeout(showResults, 800);
            } else if (state.currentIndex < quizData.questions.length && state.pendingSlots.length > 0) {
                // Show Next button if there are more questions and pending slots
                nextBtn.classList.add('show');
            }
        }

        function loadNextQuestions() {
            // Replace pending slots with new questions
            while (state.pendingSlots.length > 0 && state.currentIndex < quizData.questions.length) {
                const slot = state.pendingSlots.shift();
                state.displayedQuestions[slot] = state.currentIndex;
                state.currentIndex++;
            }

            // Hide Next button
            nextBtn.classList.remove('show');

            renderQuestions();

            // Check if quiz is complete (all displayed questions answered)
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                setTimeout(showResults, 500);
            }
        }

        function updateStats() {
            const answered = Object.keys(state.answers).length;
            const total = quizData.questions.length;

            progressBar.style.width = `${(answered / total) * 100}%`;
            progressBadge.textContent = `${answered}/${total}`;
            scoreBadge.textContent = `Score: ${state.score}`;
        }

        function showResults() {
            questionsRow.style.display = 'none';
            nextBtn.classList.remove('show');
            resultsCard.classList.add('show');

            const total = quizData.questions.length;
            const percentage = Math.round((state.score / total) * 100);

            document.getElementById('resultsScore').textContent = `${state.score}/${total}`;

            let grade, gradeClass, icon;
            if (percentage >= 90) { grade = 'Excellent! A'; gradeClass = 'grade-a'; icon = '&#127942;'; }
            else if (percentage >= 80) { grade = 'Great! B'; gradeClass = 'grade-b'; icon = '&#11088;'; }
            else if (percentage >= 70) { grade = 'Good! C'; gradeClass = 'grade-c'; icon = '&#128077;'; }
            else if (percentage >= 60) { grade = 'Pass - D'; gradeClass = 'grade-d'; icon = '&#128221;'; }
            else { grade = 'Keep practicing'; gradeClass = 'grade-f'; icon = '&#128218;'; }

            document.getElementById('resultsIcon').innerHTML = icon;
            const gradeEl = document.getElementById('resultsGrade');
            gradeEl.textContent = `${grade} (${percentage}%)`;
            gradeEl.className = `results-grade ${gradeClass}`;
        }

        function restartQuiz() {
            initQuiz();
        }

        function renderMath() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initQuiz();
            setTimeout(renderMath, 100);
        });
    </script>
</body>
</html>
