<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 11: Defi Exploits | Digital Finance</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        :root {
            --mlpurple: #3333B2;
            --mlblue: #0066CC;
            --quiz-accent: #8b5cf6;
            --quiz-light: #ede9fe;
            --correct: #22c55e;
            --correct-bg: #dcfce7;
            --incorrect: #ef4444;
            --incorrect-bg: #fee2e2;
            --bg: #f6f8fa;
            --card-bg: #ffffff;
            --text: #24292e;
            --text-secondary: #586069;
            --border: #e1e4e8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.4;
            min-height: 100vh;
        }

        .nav {
            background: linear-gradient(135deg, var(--mlpurple), var(--mlblue));
            color: white;
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nav-title { font-weight: 600; font-size: 14px; }
        .nav-links { display: flex; gap: 16px; }
        .nav-links a { color: white; text-decoration: none; font-size: 12px; opacity: 0.9; }
        .nav-links a:hover { opacity: 1; }

        .quiz-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 12px;
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 4px;
        }
        .quiz-title { font-size: 16px; font-weight: 600; color: var(--mlpurple); }
        .quiz-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }
        .stat-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .stat-progress { background: var(--quiz-light); color: var(--quiz-accent); }
        .stat-score { background: var(--correct-bg); color: var(--correct); }

        .progress-bar-container {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-bottom: 12px;
        }
        .progress-bar {
            height: 100%;
            background: var(--quiz-accent);
            border-radius: 2px;
            transition: width 0.3s;
        }

        /* Three-column layout */
        .questions-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            min-height: 280px;
        }

        .question-card.answered { opacity: 0.7; }

        .question-card.correct-card {
            border: 2px solid var(--correct);
            background: linear-gradient(to bottom, var(--correct-bg), var(--card-bg));
        }

        .question-card.incorrect-card {
            border: 2px solid var(--incorrect);
            background: linear-gradient(to bottom, var(--incorrect-bg), var(--card-bg));
        }

        .q-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .q-number {
            background: var(--quiz-light);
            color: var(--quiz-accent);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .q-status { font-size: 14px; }

        .q-text {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 10px;
            line-height: 1.4;
            flex-grow: 0;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-grow: 1;
        }

        .option-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            min-height: 44px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            font-size: 12px;
        }

        .option-btn:hover:not(.disabled) {
            border-color: var(--quiz-accent);
            background: var(--quiz-light);
        }

        .option-btn.correct {
            border-color: var(--correct);
            background: var(--correct-bg);
        }

        .option-btn.incorrect {
            border-color: var(--incorrect);
            background: var(--incorrect-bg);
        }

        .option-btn.disabled { cursor: default; }

        .option-letter {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }

        .option-btn.correct .option-letter {
            background: var(--correct);
            color: white;
        }

        .option-btn.incorrect .option-letter {
            background: var(--incorrect);
            color: white;
        }

        .option-text { flex: 1; }

        .feedback {
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.4;
            display: none;
        }

        .feedback.show { display: block; }
        .feedback.correct { background: var(--correct-bg); color: #166534; }
        .feedback.incorrect { background: var(--incorrect-bg); color: #991b1b; }

        /* Results */
        .results-card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 32px;
            text-align: center;
            max-width: 500px;
            margin: 40px auto;
            display: none;
        }
        .results-card.show { display: block; }
        .results-icon { font-size: 48px; margin-bottom: 8px; }
        .results-score { font-size: 36px; font-weight: 700; color: var(--quiz-accent); }
        .results-label { font-size: 14px; color: var(--text-secondary); margin-bottom: 16px; }
        .results-grade {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .grade-a { background: #dcfce7; color: #166534; }
        .grade-b { background: #dbeafe; color: #1e40af; }
        .grade-c { background: #fef3c7; color: #92400e; }
        .grade-d { background: #fed7aa; color: #9a3412; }
        .grade-f { background: #fee2e2; color: #991b1b; }

        .results-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            text-decoration: none;
        }
        .btn-primary { background: var(--quiz-accent); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-secondary { background: var(--card-bg); color: var(--text); border: 1px solid var(--border); }

        /* Next button container */
        .next-btn-container {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        .btn-next {
            padding: 10px 32px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            background: var(--quiz-accent);
            color: white;
            transition: all 0.2s;
            display: none;
        }
        .btn-next:hover { background: #7c3aed; transform: scale(1.02); }
        .btn-next.show { display: inline-block; }
        .btn-next:disabled { opacity: 0.5; cursor: not-allowed; }

        @media (max-width: 900px) {
            .questions-row { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 600px) {
            .questions-row { grid-template-columns: 1fr; }
            .question-card { min-height: auto; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-title">Quiz 11: Defi Exploits</div>
        <div class="nav-links">
            <a href="../index.html">Dashboard</a>
            
            <a href="https://github.com/Digital-AI-Finance/Digital-Finance-Introduction" target="_blank">GitHub</a>
        </div>
    </nav>

    <main class="quiz-container">
        <div class="quiz-header">
            <div class="quiz-title">Quiz 11: Defi Exploits</div>
            <div class="quiz-stats">
                <span class="stat-badge stat-progress" id="progressBadge">0/20</span>
                <span class="stat-badge stat-score" id="scoreBadge">Score: 0</span>
            </div>
        </div>

        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>

        <div class="questions-row" id="questionsRow"></div>

        <div class="next-btn-container">
            <button class="btn-next" id="nextBtn" onclick="loadNextQuestions()">Next</button>
        </div>

        <div class="results-card" id="resultsCard">
            <div class="results-icon" id="resultsIcon"></div>
            <div class="results-score" id="resultsScore"></div>
            <div class="results-label">Correct Answers</div>
            <div class="results-grade" id="resultsGrade"></div>
            <div class="results-buttons">
                <button class="btn btn-primary" onclick="restartQuiz()">Try Again</button>
                <a href="../index.html" class="btn btn-secondary">Dashboard</a>
            </div>
        </div>
    </main>

    <script>
        const quizData = {
            questions: [
                {
                                "id": 1,
                                "question": "What is a reentrancy attack in the context of smart contracts?",
                                "options": {
                                                "A": "When a contract calls the same function multiple times in sequence",
                                                "B": "When an external contract calls back into the original contract before the first execution completes",
                                                "C": "When multiple users try to access a contract simultaneously",
                                                "D": "When a contract fails to execute and automatically retries"
                                },
                                "correct": "B",
                                "explanation": "A reentrancy attack occurs when a contract makes an external call (e.g., sending ETH) and that external address calls back into the original contract before the first execution completes. This allows attackers to exploit state that hasn't been updated yet, potentially draining funds.",
                                "difficulty": "easy"
                },
                {
                                "id": 2,
                                "question": "Why are smart contracts vulnerable to reentrancy attacks?",
                                "options": {
                                                "A": "Because Solidity doesn't support recursive function calls",
                                                "B": "Because external calls can transfer control before state updates are completed",
                                                "C": "Because contracts cannot validate the caller's address",
                                                "D": "Because blockchain transactions are reversible"
                                },
                                "correct": "B",
                                "explanation": "Reentrancy is possible because when a contract makes an external call (like sending ETH), it transfers execution control to the recipient. If the contract updates its state AFTER this external call, the recipient can call back into the original contract and exploit the not-yet-updated state. This is why updating state before external calls is critical.",
                                "difficulty": "medium"
                },
                {
                                "id": 3,
                                "question": "What was the significance of The DAO hack in 2016?",
                                "options": {
                                                "A": "It was the first cryptocurrency theft in history",
                                                "B": "It exploited a reentrancy vulnerability and led to the Ethereum hard fork",
                                                "C": "It proved that smart contracts cannot be hacked",
                                                "D": "It introduced the concept of flash loans to DeFi"
                                },
                                "correct": "B",
                                "explanation": "The DAO hack in June 2016 was the first major DeFi exploit, where an attacker used a reentrancy vulnerability to steal 3.6 million ETH (~$60M at the time). The Ethereum community responded with a controversial hard fork to return the stolen funds, creating Ethereum (ETH) and Ethereum Classic (ETC). This event established the critical importance of smart contract security.",
                                "difficulty": "easy"
                },
                {
                                "id": 4,
                                "question": "What is the correct order for the Checks-Effects-Interactions pattern?",
                                "options": {
                                                "A": "Make external calls, validate conditions, update state",
                                                "B": "Validate conditions, make external calls, update state",
                                                "C": "Validate conditions, update state, make external calls",
                                                "D": "Update state, validate conditions, make external calls"
                                },
                                "correct": "C",
                                "explanation": "The Checks-Effects-Interactions (CEI) pattern is a fundamental security practice: (1) CHECK - validate all conditions and requirements, (2) EFFECTS - update contract state (balances, mappings, etc.), (3) INTERACTIONS - make external calls last. This prevents reentrancy by ensuring state is updated before any external code can be executed.",
                                "difficulty": "medium"
                },
                {
                                "id": 5,
                                "question": "What is the purpose of a ReentrancyGuard modifier in Solidity?",
                                "options": {
                                                "A": "To optimize gas costs for repeated function calls",
                                                "B": "To prevent a function from being called while it is still executing",
                                                "C": "To allow only the contract owner to call certain functions",
                                                "D": "To automatically revert failed transactions"
                                },
                                "correct": "B",
                                "explanation": "A ReentrancyGuard (also called a mutex or lock) uses a state variable to track whether a function is currently executing. It sets a lock at the start of execution and clears it at the end. If the function is called again while the lock is active (reentrancy attempt), the guard blocks the call. This provides an additional layer of protection against reentrancy attacks beyond the CEI pattern.",
                                "difficulty": "easy"
                },
                {
                                "id": 6,
                                "question": "What is a flash loan in DeFi?",
                                "options": {
                                                "A": "A loan that must be approved within 1 minute",
                                                "B": "An uncollateralized loan that must be borrowed and repaid within the same blockchain transaction",
                                                "C": "A loan with an extremely high interest rate",
                                                "D": "A loan that uses lightning network for instant settlement"
                                },
                                "correct": "B",
                                "explanation": "A flash loan is an uncollateralized loan where the borrowing and repayment must occur within a single atomic transaction (same block). If the borrower cannot repay the loan plus fees by the end of the transaction, the entire transaction reverts, including the loan itself. This allows borrowing millions of dollars with zero collateral, but only for operations that complete instantly.",
                                "difficulty": "easy"
                },
                {
                                "id": 7,
                                "question": "What does 'atomic property' mean in the context of flash loans?",
                                "options": {
                                                "A": "The loan amount must be very small, like an atom",
                                                "B": "The loan uses atomic swaps for cross-chain compatibility",
                                                "C": "All operations (borrow, use, repay) must happen in a single transaction or everything reverts",
                                                "D": "The loan is secured by atomic layer blockchain technology"
                                },
                                "correct": "C",
                                "explanation": "The atomic property means that flash loans operate as an all-or-nothing transaction. The borrow, any operations using the borrowed funds, and the repayment must all occur within a single blockchain transaction. If any step fails or if repayment is insufficient, the entire transaction reverts as if it never happened. This atomicity is what allows flash loans to be uncollateralized.",
                                "difficulty": "medium"
                },
                {
                                "id": 8,
                                "question": "Why do flash loans enable attacks on DeFi protocols?",
                                "options": {
                                                "A": "They allow attackers to borrow large amounts without collateral to manipulate markets or exploit vulnerabilities",
                                                "B": "They bypass all security checks in smart contracts",
                                                "C": "They make transactions untraceable on the blockchain",
                                                "D": "They can reverse completed blockchain transactions"
                                },
                                "correct": "A",
                                "explanation": "Flash loans democratize access to large capital (millions of dollars) without requiring any upfront collateral. This enables attackers to execute complex exploits that would otherwise require significant personal funds, such as manipulating DEX prices to exploit oracle vulnerabilities, executing governance attacks by borrowing voting tokens, or amplifying other attack vectors. The attacker only needs to pay a small fee (typically 0.05-0.09%) if the attack succeeds.",
                                "difficulty": "medium"
                },
                {
                                "id": 9,
                                "question": "What is oracle manipulation in DeFi?",
                                "options": {
                                                "A": "Hacking the Oracle database system used by smart contracts",
                                                "B": "Bribing the administrators who run price feed services",
                                                "C": "Artificially moving market prices to deceive protocols that rely on price data",
                                                "D": "Using AI oracles to predict future price movements"
                                },
                                "correct": "C",
                                "explanation": "Oracle manipulation occurs when an attacker artificially influences the price data that a DeFi protocol uses to make decisions. For example, by making large trades on a DEX, an attacker can temporarily inflate or deflate the spot price. If a lending protocol uses this manipulated price to value collateral, the attacker can borrow more than their collateral is truly worth. This is especially effective when combined with flash loans.",
                                "difficulty": "medium"
                },
                {
                                "id": 10,
                                "question": "What is the key difference between spot price and TWAP oracle pricing?",
                                "options": {
                                                "A": "Spot price is always more accurate than TWAP",
                                                "B": "TWAP uses time-weighted average prices over a period, making it resistant to short-term manipulation",
                                                "C": "Spot price requires multiple data sources while TWAP uses only one",
                                                "D": "TWAP is cheaper to implement but less secure"
                                },
                                "correct": "B",
                                "explanation": "Spot price reflects the current instant price from a single source, which can be easily manipulated with a large trade in a single transaction (especially using flash loans). TWAP (Time-Weighted Average Price) calculates an average price over a historical window (e.g., 30 minutes), making it much more expensive and difficult to manipulate since the attacker would need to sustain the manipulation across many blocks, not just one transaction.",
                                "difficulty": "hard"
                },
                {
                                "id": 11,
                                "question": "What are the main advantages of Chainlink oracles over single-source DEX price feeds?",
                                "options": {
                                                "A": "They are completely free to use with no fees",
                                                "B": "They aggregate data from multiple sources and use decentralized node operators",
                                                "C": "They update prices every second for maximum accuracy",
                                                "D": "They eliminate the need for smart contracts entirely"
                                },
                                "correct": "B",
                                "explanation": "Chainlink oracles provide security through decentralization and redundancy: they aggregate price data from multiple independent sources (exchanges, data providers), use a network of decentralized node operators to fetch and verify data, and employ cryptographic proofs. This makes manipulation extremely difficult compared to single-source oracles like spot prices from a single DEX, which can be manipulated with one large trade.",
                                "difficulty": "hard"
                },
                {
                                "id": 12,
                                "question": "What type of vulnerability is demonstrated when any user can call a function that should be restricted to administrators?",
                                "options": {
                                                "A": "Reentrancy vulnerability",
                                                "B": "Access control vulnerability",
                                                "C": "Integer overflow vulnerability",
                                                "D": "Oracle manipulation vulnerability"
                                },
                                "correct": "B",
                                "explanation": "This is a classic access control vulnerability, where functions that should be restricted to specific roles (owner, admin, authorized users) are missing proper permission checks. For example, if a 'setOwner()' function or 'withdrawAll()' function doesn't check 'require(msg.sender == owner)', anyone can call it and potentially take control of the contract or drain funds. Proper access control using modifiers like 'onlyOwner' or 'onlyAdmin' is essential.",
                                "difficulty": "easy"
                },
                {
                                "id": 13,
                                "question": "What is the purpose of a timelock pattern in governance?",
                                "options": {
                                                "A": "To make transactions execute faster by locking them in advance",
                                                "B": "To delay the execution of sensitive operations, allowing time for review and intervention",
                                                "C": "To lock user funds for a specific time period to prevent withdrawal",
                                                "D": "To synchronize time across different blockchain networks"
                                },
                                "correct": "B",
                                "explanation": "Timelocks add a mandatory delay (e.g., 2 days) between when an administrative action is proposed and when it can be executed. This gives the community time to review proposed changes, detect malicious actions, and respond (e.g., exit the protocol) before harmful changes take effect. Timelocks are particularly important for governance functions and help prevent rushed or malicious governance attacks where an attacker temporarily controls voting power.",
                                "difficulty": "medium"
                },
                {
                                "id": 14,
                                "question": "What is the difference between pull and push payment patterns, and why does it matter for security?",
                                "options": {
                                                "A": "Pull is slower but push is faster; speed is the main security concern",
                                                "B": "Pull lets users withdraw funds themselves; push sends funds to them automatically; pull is safer against DoS and reentrancy",
                                                "C": "Push requires user approval while pull happens automatically",
                                                "D": "There is no security difference, only a stylistic preference"
                                },
                                "correct": "B",
                                "explanation": "In the push pattern, the contract sends funds to recipients (often in a loop), which can fail if a recipient's fallback function reverts (DoS) or contains malicious reentrancy code. In the pull pattern, the contract records what users are owed, and they withdraw it themselves. Pull is safer because: (1) a failed withdrawal only affects that user, not others, (2) the user controls when external calls happen, and (3) it's easier to secure against reentrancy with CEI pattern.",
                                "difficulty": "hard"
                },
                {
                                "id": 15,
                                "question": "What security issue existed with integer operations in Solidity versions before 0.8.0?",
                                "options": {
                                                "A": "Integers could only store small numbers up to 255",
                                                "B": "Integer overflow and underflow could occur silently without reverting the transaction",
                                                "C": "Integer division always rounded up instead of down",
                                                "D": "Integers consumed excessive gas making operations expensive"
                                },
                                "correct": "B",
                                "explanation": "In Solidity versions before 0.8.0, arithmetic operations could overflow (exceed maximum value) or underflow (go below zero) without reverting, wrapping around to unexpected values. For example, if a uint256 at 0 is decreased by 1, it underflows to 2^256-1, an enormous number. This allowed exploits like unlimited token minting. Solidity 0.8.0+ has built-in overflow/underflow checks, and earlier versions required SafeMath library.",
                                "difficulty": "hard"
                },
                {
                                "id": 16,
                                "question": "In smart contract audits, what severity level requires immediate action before deployment?",
                                "options": {
                                                "A": "Low severity - minor issues",
                                                "B": "Medium severity - moderate risks",
                                                "C": "Critical severity - direct loss of funds or complete compromise",
                                                "D": "Informational - observations and suggestions"
                                },
                                "correct": "C",
                                "explanation": "Critical severity findings represent direct threats of fund loss or complete contract compromise (e.g., reentrancy allowing drainage, missing access control on withdrawal, integer overflow enabling infinite minting). These MUST be fixed before deployment. High severity issues should be fixed, Medium issues are recommended to fix, Low issues can be considered, and Informational findings are suggestions for improvement.",
                                "difficulty": "easy"
                },
                {
                                "id": 17,
                                "question": "Which of the following represents one of the largest DeFi exploits by dollar amount?",
                                "options": {
                                                "A": "The DAO hack: $60 million (2016)",
                                                "B": "Ronin Bridge hack: $625 million (2022)",
                                                "C": "bZx hack: $8 million (2020)",
                                                "D": "Yearn Finance hack: $11 million (2021)"
                                },
                                "correct": "B",
                                "explanation": "The Ronin Bridge hack (March 2022) resulted in $625 million stolen (173,600 ETH + 25.5M USDC), making it one of the largest crypto hacks ever. It involved compromise of 5 out of 9 validator private keys through social engineering by the Lazarus Group. While The DAO hack was historically significant, it was 'only' $60M. This highlights that bridge attacks have become the most costly category of DeFi exploits.",
                                "difficulty": "medium"
                },
                {
                                "id": 18,
                                "question": "Why are bug bounty programs important for DeFi security?",
                                "options": {
                                                "A": "They provide free marketing for DeFi protocols",
                                                "B": "They incentivize ethical hackers to report vulnerabilities before malicious actors exploit them",
                                                "C": "They replace the need for formal security audits",
                                                "D": "They guarantee that protocols will never be hacked"
                                },
                                "correct": "B",
                                "explanation": "Bug bounty programs offer financial rewards to security researchers who discover and responsibly disclose vulnerabilities, incentivizing ethical disclosure rather than exploitation. Platforms like Immunefi have paid out millions to white-hat hackers. This provides continuous security testing beyond point-in-time audits, as protocols evolve and new vulnerabilities emerge. However, bug bounties complement but don't replace formal audits.",
                                "difficulty": "easy"
                },
                {
                                "id": 19,
                                "question": "What happens during the manual review phase of a smart contract security audit?",
                                "options": {
                                                "A": "Auditors only run automated scanning tools on the code",
                                                "B": "Auditors perform line-by-line code review, analyze business logic, and identify edge cases",
                                                "C": "Users manually test the application's user interface",
                                                "D": "The development team reviews their own code without external help"
                                },
                                "correct": "B",
                                "explanation": "Manual review is the core of a security audit where expert auditors examine the code line-by-line, looking for vulnerabilities that automated tools miss. This includes analyzing business logic correctness, verifying access controls, identifying edge cases, checking integration points, and understanding the protocol's economic mechanisms. Automated tools complement but cannot replace human expertise in finding complex logical vulnerabilities and attack vectors.",
                                "difficulty": "medium"
                },
                {
                                "id": 20,
                                "question": "What is the 'defense in depth' principle in DeFi security?",
                                "options": {
                                                "A": "Using only the strongest single security measure available",
                                                "B": "Implementing multiple layers of security controls so that if one fails, others still protect the system",
                                                "C": "Focusing all security resources on protecting the most valuable function",
                                                "D": "Defending only the smart contract layer and ignoring infrastructure"
                                },
                                "correct": "B",
                                "explanation": "Defense in depth means implementing multiple independent security layers so that a single point of failure doesn't compromise the entire system. For DeFi, this includes: secure code patterns (CEI, reentrancy guards), multiple audits, bug bounties, TWAP oracles with multiple sources, access controls with timelocks, circuit breakers, monitoring systems, and incident response plans. Even if one control fails (e.g., a bug passes audit), other layers can prevent or limit the damage.",
                                "difficulty": "hard"
                }
]
        };

        const state = {
            currentIndex: 0,
            answers: {},
            score: 0,
            displayedQuestions: [],
            pendingSlots: []
        };

        const questionsRow = document.getElementById('questionsRow');
        const progressBar = document.getElementById('progressBar');
        const progressBadge = document.getElementById('progressBadge');
        const scoreBadge = document.getElementById('scoreBadge');
        const resultsCard = document.getElementById('resultsCard');
        const nextBtn = document.getElementById('nextBtn');

        function initQuiz() {
            state.currentIndex = 0;
            state.answers = {};
            state.score = 0;
            state.displayedQuestions = [];
            state.pendingSlots = [];

            resultsCard.classList.remove('show');
            questionsRow.style.display = 'grid';
            nextBtn.classList.remove('show');

            // Show first 3 questions
            for (let i = 0; i < 3 && i < quizData.questions.length; i++) {
                state.displayedQuestions.push(i);
            }
            state.currentIndex = Math.min(3, quizData.questions.length);

            renderQuestions();
            updateStats();
        }

        function renderQuestions() {
            questionsRow.innerHTML = '';

            state.displayedQuestions.forEach((qIdx, slot) => {
                const q = quizData.questions[qIdx];
                const answered = state.answers[q.id] !== undefined;
                const isCorrect = answered && state.answers[q.id] === q.correct;
                const isIncorrect = answered && state.answers[q.id] !== q.correct;

                const card = document.createElement('div');
                card.className = 'question-card';
                if (isCorrect) card.classList.add('correct-card', 'answered');
                if (isIncorrect) card.classList.add('incorrect-card', 'answered');

                card.innerHTML = `
                    <div class="q-header">
                        <span class="q-number">Q${qIdx + 1}</span>
                        ${answered ? `<span class="q-status">${isCorrect ? '&#10004;' : '&#10008;'}</span>` : ''}
                    </div>
                    <div class="q-text">${q.question}</div>
                    <div class="options" data-qid="${q.id}" data-slot="${slot}">
                        ${['A','B','C','D'].map(letter => {
                            let optClass = 'option-btn';
                            if (answered) {
                                optClass += ' disabled';
                                if (letter === q.correct) optClass += ' correct';
                                else if (letter === state.answers[q.id]) optClass += ' incorrect';
                            }
                            return `
                                <button class="${optClass}" data-letter="${letter}" ${answered ? 'disabled' : ''}>
                                    <span class="option-letter">${letter}</span>
                                    <span class="option-text">${q.options[letter]}</span>
                                </button>
                            `;
                        }).join('')}
                    </div>
                    <div class="feedback ${answered ? 'show' : ''} ${isCorrect ? 'correct' : 'incorrect'}">
                        ${answered ? (isCorrect ? '&#10004; ' : `&#10008; Answer: ${q.correct}. `) + q.explanation : ''}
                    </div>
                `;

                // Add click handlers
                if (!answered) {
                    card.querySelectorAll('.option-btn').forEach(btn => {
                        btn.addEventListener('click', () => handleAnswer(qIdx, slot, btn.dataset.letter));
                    });
                }

                questionsRow.appendChild(card);
            });

            renderMath();
        }

        function handleAnswer(qIdx, slot, letter) {
            const q = quizData.questions[qIdx];
            state.answers[q.id] = letter;

            if (letter === q.correct) state.score++;

            // Track this slot as pending replacement
            if (!state.pendingSlots.includes(slot)) {
                state.pendingSlots.push(slot);
            }

            updateStats();
            renderQuestions();

            // Check if all questions answered
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                // Short delay then show results
                setTimeout(showResults, 800);
            } else if (state.currentIndex < quizData.questions.length && state.pendingSlots.length > 0) {
                // Show Next button if there are more questions and pending slots
                nextBtn.classList.add('show');
            }
        }

        function loadNextQuestions() {
            // Replace pending slots with new questions
            while (state.pendingSlots.length > 0 && state.currentIndex < quizData.questions.length) {
                const slot = state.pendingSlots.shift();
                state.displayedQuestions[slot] = state.currentIndex;
                state.currentIndex++;
            }

            // Hide Next button
            nextBtn.classList.remove('show');

            renderQuestions();

            // Check if quiz is complete (all displayed questions answered)
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                setTimeout(showResults, 500);
            }
        }

        function updateStats() {
            const answered = Object.keys(state.answers).length;
            const total = quizData.questions.length;

            progressBar.style.width = `${(answered / total) * 100}%`;
            progressBadge.textContent = `${answered}/${total}`;
            scoreBadge.textContent = `Score: ${state.score}`;
        }

        function showResults() {
            questionsRow.style.display = 'none';
            nextBtn.classList.remove('show');
            resultsCard.classList.add('show');

            const total = quizData.questions.length;
            const percentage = Math.round((state.score / total) * 100);

            document.getElementById('resultsScore').textContent = `${state.score}/${total}`;

            let grade, gradeClass, icon;
            if (percentage >= 90) { grade = 'Excellent! A'; gradeClass = 'grade-a'; icon = '&#127942;'; }
            else if (percentage >= 80) { grade = 'Great! B'; gradeClass = 'grade-b'; icon = '&#11088;'; }
            else if (percentage >= 70) { grade = 'Good! C'; gradeClass = 'grade-c'; icon = '&#128077;'; }
            else if (percentage >= 60) { grade = 'Pass - D'; gradeClass = 'grade-d'; icon = '&#128221;'; }
            else { grade = 'Keep practicing'; gradeClass = 'grade-f'; icon = '&#128218;'; }

            document.getElementById('resultsIcon').innerHTML = icon;
            const gradeEl = document.getElementById('resultsGrade');
            gradeEl.textContent = `${grade} (${percentage}%)`;
            gradeEl.className = `results-grade ${gradeClass}`;
        }

        function restartQuiz() {
            initQuiz();
        }

        function renderMath() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initQuiz();
            setTimeout(renderMath, 100);
        });
    </script>
</body>
</html>
