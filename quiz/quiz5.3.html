<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 5.3: Dao Governance | Introduction to Digital Finance</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        :root {
            --mlpurple: #3333B2;
            --mlblue: #0066CC;
            --quiz-accent: #8b5cf6;
            --quiz-light: #ede9fe;
            --correct: #22c55e;
            --correct-bg: #dcfce7;
            --incorrect: #ef4444;
            --incorrect-bg: #fee2e2;
            --bg: #f6f8fa;
            --card-bg: #ffffff;
            --text: #24292e;
            --text-secondary: #586069;
            --border: #e1e4e8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.4;
            min-height: 100vh;
        }

        .nav {
            background: linear-gradient(135deg, var(--mlpurple), var(--mlblue));
            color: white;
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nav-title { font-weight: 600; font-size: 14px; }
        .nav-links { display: flex; gap: 16px; }
        .nav-links a { color: white; text-decoration: none; font-size: 12px; opacity: 0.9; }
        .nav-links a:hover { opacity: 1; }

        .quiz-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 12px;
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 4px;
        }
        .quiz-title { font-size: 16px; font-weight: 600; color: var(--mlpurple); }
        .quiz-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }
        .stat-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .stat-progress { background: var(--quiz-light); color: var(--quiz-accent); }
        .stat-score { background: var(--correct-bg); color: var(--correct); }

        .progress-bar-container {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-bottom: 12px;
        }
        .progress-bar {
            height: 100%;
            background: var(--quiz-accent);
            border-radius: 2px;
            transition: width 0.3s;
        }

        /* Three-column layout */
        .questions-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            min-height: 280px;
        }

        .question-card.answered { opacity: 0.7; }

        .question-card.correct-card {
            border: 2px solid var(--correct);
            background: linear-gradient(to bottom, var(--correct-bg), var(--card-bg));
        }

        .question-card.incorrect-card {
            border: 2px solid var(--incorrect);
            background: linear-gradient(to bottom, var(--incorrect-bg), var(--card-bg));
        }

        .q-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .q-number {
            background: var(--quiz-light);
            color: var(--quiz-accent);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .q-status { font-size: 14px; }

        .q-text {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 10px;
            line-height: 1.4;
            flex-grow: 0;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-grow: 1;
        }

        .option-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            min-height: 44px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            font-size: 12px;
        }

        .option-btn:hover:not(.disabled) {
            border-color: var(--quiz-accent);
            background: var(--quiz-light);
        }

        .option-btn.correct {
            border-color: var(--correct);
            background: var(--correct-bg);
        }

        .option-btn.incorrect {
            border-color: var(--incorrect);
            background: var(--incorrect-bg);
        }

        .option-btn.disabled { cursor: default; }

        .option-letter {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }

        .option-btn.correct .option-letter {
            background: var(--correct);
            color: white;
        }

        .option-btn.incorrect .option-letter {
            background: var(--incorrect);
            color: white;
        }

        .option-text { flex: 1; }

        .feedback {
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.4;
            display: none;
        }

        .feedback.show { display: block; }
        .feedback.correct { background: var(--correct-bg); color: #166534; }
        .feedback.incorrect { background: var(--incorrect-bg); color: #991b1b; }

        /* Results */
        .results-card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 32px;
            text-align: center;
            max-width: 500px;
            margin: 40px auto;
            display: none;
        }
        .results-card.show { display: block; }
        .results-icon { font-size: 48px; margin-bottom: 8px; }
        .results-score { font-size: 36px; font-weight: 700; color: var(--quiz-accent); }
        .results-label { font-size: 14px; color: var(--text-secondary); margin-bottom: 16px; }
        .results-grade {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .grade-a { background: #dcfce7; color: #166534; }
        .grade-b { background: #dbeafe; color: #1e40af; }
        .grade-c { background: #fef3c7; color: #92400e; }
        .grade-d { background: #fed7aa; color: #9a3412; }
        .grade-f { background: #fee2e2; color: #991b1b; }

        .results-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            text-decoration: none;
        }
        .btn-primary { background: var(--quiz-accent); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-secondary { background: var(--card-bg); color: var(--text); border: 1px solid var(--border); }

        /* Next button container */
        .next-btn-container {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        .btn-next {
            padding: 10px 32px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            background: var(--quiz-accent);
            color: white;
            transition: all 0.2s;
            display: none;
        }
        .btn-next:hover { background: #7c3aed; transform: scale(1.02); }
        .btn-next.show { display: inline-block; }
        .btn-next:disabled { opacity: 0.5; cursor: not-allowed; }

        @media (max-width: 900px) {
            .questions-row { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 600px) {
            .questions-row { grid-template-columns: 1fr; }
            .question-card { min-height: auto; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-title">Quiz 5.3: Dao Governance</div>
        <div class="nav-links">
            <a href="../index.html">Dashboard</a>
            
            <a href="https://github.com/Digital-AI-Finance/Digital-Finance-Introduction" target="_blank">GitHub</a>
        </div>
    </nav>

    <main class="quiz-container">
        <div class="quiz-header">
            <div class="quiz-title">Quiz 5.3: Dao Governance</div>
            <div class="quiz-stats">
                <span class="stat-badge stat-progress" id="progressBadge">0/20</span>
                <span class="stat-badge stat-score" id="scoreBadge">Score: 0</span>
            </div>
        </div>

        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>

        <div class="questions-row" id="questionsRow"></div>

        <div class="next-btn-container">
            <button class="btn-next" id="nextBtn" onclick="loadNextQuestions()">Next</button>
        </div>

        <div class="results-card" id="resultsCard">
            <div class="results-icon" id="resultsIcon"></div>
            <div class="results-score" id="resultsScore"></div>
            <div class="results-label">Correct Answers</div>
            <div class="results-grade" id="resultsGrade"></div>
            <div class="results-buttons">
                <button class="btn btn-primary" onclick="restartQuiz()">Try Again</button>
                <a href="../index.html" class="btn btn-secondary">Dashboard</a>
            </div>
        </div>
    </main>

    <script>
        const quizData = {
            questions: [
                {
                                "id": 1,
                                "difficulty": "easy",
                                "topic": "DAO definition",
                                "question": "What does DAO stand for in the context of blockchain governance?",
                                "options": {
                                                "A": "Distributed Autonomous Operation",
                                                "B": "Decentralized Autonomous Organization",
                                                "C": "Digital Asset Organization",
                                                "D": "Delegated Authority Operation"
                                },
                                "correct": "B",
                                "explanation": "DAO stands for Decentralized Autonomous Organization. It is an organization represented by rules encoded as a computer program that is transparent, controlled by organization members (typically through governance tokens), and not influenced by a central government. DAOs automate decision-making through smart contracts and token-based voting."
                },
                {
                                "id": 2,
                                "difficulty": "easy",
                                "topic": "Governance token purpose",
                                "question": "What is the primary purpose of a governance token in a DAO?",
                                "options": {
                                                "A": "To pay transaction fees on the blockchain",
                                                "B": "To represent voting power in organizational decisions",
                                                "C": "To provide liquidity for decentralized exchanges",
                                                "D": "To serve as collateral for lending protocols"
                                },
                                "correct": "B",
                                "explanation": "The primary purpose of a governance token is to represent voting power in organizational decisions. While governance tokens may have other utilities, their core function is to enable token holders to vote on proposals that affect the protocol or organization. The amount of tokens held typically determines the weight of a holder's vote in governance decisions."
                },
                {
                                "id": 3,
                                "difficulty": "medium",
                                "topic": "On-chain vs off-chain governance",
                                "question": "Which statement best describes the difference between on-chain and off-chain governance?",
                                "options": {
                                                "A": "On-chain governance is faster but off-chain is more secure",
                                                "B": "On-chain governance executes decisions automatically via smart contracts, while off-chain governance requires manual implementation",
                                                "C": "On-chain governance is free while off-chain governance requires gas fees",
                                                "D": "On-chain governance is anonymous while off-chain governance requires identity verification"
                                },
                                "correct": "B",
                                "explanation": "The key difference is that on-chain governance has the voting and execution happen directly on the blockchain via smart contracts - once a proposal passes, it executes automatically. Off-chain governance (like Snapshot voting) records votes off-chain (often gas-free), but approved proposals still require manual implementation by administrators or multi-sig holders. On-chain governance provides true automation but at the cost of gas fees and less flexibility."
                },
                {
                                "id": 4,
                                "difficulty": "easy",
                                "topic": "Token-weighted voting",
                                "question": "In standard token-weighted voting, how is voting power determined?",
                                "options": {
                                                "A": "Each wallet address gets one vote regardless of token holdings",
                                                "B": "Each token equals one vote",
                                                "C": "Voting power is based on the square root of tokens held",
                                                "D": "Voting power increases the longer tokens are held"
                                },
                                "correct": "B",
                                "explanation": "In standard token-weighted voting (also called plutocratic voting), each token equals one vote. If you hold 100 tokens, you get 100 votes. This is the most common governance mechanism in DAOs. It's simple and aligns voting power with economic stake, but leads to wealth concentration equaling power concentration, where large holders (whales) can dominate decisions."
                },
                {
                                "id": 5,
                                "difficulty": "medium",
                                "topic": "Quadratic voting concept",
                                "question": "In quadratic voting, if a holder has 10,000 tokens, what is their voting power?",
                                "options": {
                                                "A": "10,000 votes",
                                                "B": "1,000 votes",
                                                "C": "100 votes",
                                                "D": "5,000 votes"
                                },
                                "correct": "C",
                                "explanation": "In quadratic voting, voting power equals the square root of tokens held. So 10,000 tokens = sqrt(10,000) = 100 votes. This dramatically reduces the influence of large holders compared to linear voting where 10,000 tokens would equal 10,000 votes. For example, someone with 100 tokens gets 10 votes, meaning the large holder only has 10x the power despite having 100x the tokens. This mechanism aims to give smaller holders proportionally more voice."
                },
                {
                                "id": 6,
                                "difficulty": "hard",
                                "topic": "Quadratic voting vulnerability",
                                "question": "What is the primary vulnerability that limits the effectiveness of quadratic voting in DAOs?",
                                "options": {
                                                "A": "It requires too much computational power to calculate votes",
                                                "B": "It is vulnerable to Sybil attacks where users split tokens across multiple wallets",
                                                "C": "It cannot be implemented in smart contracts",
                                                "D": "It makes proposals take longer to pass"
                                },
                                "correct": "B",
                                "explanation": "The primary vulnerability of quadratic voting is Sybil attacks. A user can split their tokens across multiple wallets to gain more voting power. For example, 10,000 tokens in one wallet = 100 votes, but the same 10,000 tokens split into 100 wallets of 100 tokens each = 100 × 10 = 1,000 votes! This defeats the entire purpose of quadratic voting. To be truly effective, quadratic voting requires robust identity verification (like Proof of Humanity) to prevent users from creating multiple identities."
                },
                {
                                "id": 7,
                                "difficulty": "medium",
                                "topic": "Conviction voting concept",
                                "question": "How does conviction voting differ from standard token-weighted voting?",
                                "options": {
                                                "A": "Votes are counted based on token price instead of quantity",
                                                "B": "Voting power increases the longer tokens are staked on a position",
                                                "C": "Only voters who achieve consensus receive voting power",
                                                "D": "Voting power decreases over time to encourage quick decisions"
                                },
                                "correct": "B",
                                "explanation": "In conviction voting, voting power increases the longer tokens remain staked on a particular position. Using a formula like conviction = balance × (1 - decay^days), voting power grows asymptotically over time (typically reaching maximum after ~30 days). This mechanism rewards long-term commitment and reduces the effectiveness of short-term manipulation like flash loan attacks, since attackers cannot accumulate conviction instantly. It encourages thoughtful, sustained support rather than quick vote-and-exit behavior."
                },
                {
                                "id": 8,
                                "difficulty": "easy",
                                "topic": "Delegation mechanics",
                                "question": "What happens when you delegate your governance tokens to another address?",
                                "options": {
                                                "A": "You permanently transfer ownership of your tokens",
                                                "B": "The delegate can vote with your token's voting power on your behalf",
                                                "C": "Your tokens are locked and cannot be moved",
                                                "D": "You lose all rights to your tokens until delegation is revoked"
                                },
                                "correct": "B",
                                "explanation": "When you delegate your governance tokens, the delegate can vote with your token's voting power on your behalf, but you retain ownership of your tokens. You can still transfer or sell them, and you can revoke the delegation at any time. This is called liquid democracy - it allows token holders who don't want to actively participate in every vote to lend their voting power to trusted community members who will represent their interests."
                },
                {
                                "id": 9,
                                "difficulty": "medium",
                                "topic": "Proposal lifecycle",
                                "question": "What is the typical lifecycle sequence for a DAO governance proposal?",
                                "options": {
                                                "A": "Create → Execute → Vote → Finalize",
                                                "B": "Vote → Create → Execute → Queue",
                                                "C": "Create → Vote → Queue → Execute",
                                                "D": "Queue → Vote → Create → Execute"
                                },
                                "correct": "C",
                                "explanation": "The typical proposal lifecycle is: Create (a proposer with sufficient tokens submits a proposal) → Vote (token holders vote during the voting period) → Queue (if passed, the proposal enters a timelock queue) → Execute (after the timelock delay, the proposal is executed on-chain). Some variations exist, but this sequence includes important security mechanisms like the proposal threshold (preventing spam) and timelock (allowing community reaction time before execution)."
                },
                {
                                "id": 10,
                                "difficulty": "easy",
                                "topic": "Quorum requirements",
                                "question": "What does 'quorum' mean in the context of DAO governance?",
                                "options": {
                                                "A": "The minimum percentage of 'yes' votes needed to pass a proposal",
                                                "B": "The minimum participation threshold required for a vote to be valid",
                                                "C": "The maximum number of proposals that can be active at once",
                                                "D": "The fee required to submit a governance proposal"
                                },
                                "correct": "B",
                                "explanation": "Quorum is the minimum participation threshold required for a vote to be valid. For example, if quorum is set at 4%, at least 4% of the total token supply must participate in voting for the proposal to be considered valid, regardless of the outcome. This prevents a tiny minority from making decisions when most of the community is not engaged. A proposal might have 100% approval but still fail if quorum is not met. Typical quorum requirements in real DAOs range from 4% to 10%."
                },
                {
                                "id": 11,
                                "difficulty": "medium",
                                "topic": "Timelock delay for execution",
                                "question": "Why do many DAOs implement a timelock delay between proposal approval and execution?",
                                "options": {
                                                "A": "To allow gas prices to decrease before executing transactions",
                                                "B": "To give the community time to review and potentially exit if they disagree with a malicious proposal",
                                                "C": "To ensure all voters have time to change their votes",
                                                "D": "To wait for the proposal to be validated by external auditors"
                                },
                                "correct": "B",
                                "explanation": "Timelock delays (typically 24-72 hours) give the community time to review approved proposals and potentially react if something malicious is detected. During this window, users who disagree can exit the protocol, guardians can cancel truly dangerous proposals, and the community can organize opposition. This is a critical security mechanism because once voting ends, there's no other protection against a successfully passed but harmful proposal. Real DAOs like Uniswap use 168-hour (7-day) timelocks for maximum security."
                },
                {
                                "id": 12,
                                "difficulty": "easy",
                                "topic": "Snapshot voting",
                                "question": "What is the main advantage of Snapshot-based voting compared to on-chain voting?",
                                "options": {
                                                "A": "Snapshot voting provides better security through blockchain verification",
                                                "B": "Snapshot voting is gas-free for voters",
                                                "C": "Snapshot voting allows anonymous voting",
                                                "D": "Snapshot voting automatically executes approved proposals"
                                },
                                "correct": "B",
                                "explanation": "The main advantage of Snapshot voting is that it's gas-free for voters. Snapshot records votes off-chain using cryptographic signatures, eliminating the need for expensive blockchain transactions for each vote. This dramatically increases participation, especially from smaller holders who might not vote if it costs $10-50 in gas fees. However, the tradeoff is that Snapshot voting is off-chain governance - approved proposals still need to be manually implemented by the team or multi-sig, rather than executing automatically like on-chain governance."
                },
                {
                                "id": 13,
                                "difficulty": "medium",
                                "topic": "Multi-sig treasury management",
                                "question": "In a 3-of-5 multi-signature wallet setup, how many signers must approve a transaction before it can be executed?",
                                "options": {
                                                "A": "Any 1 of the 5 signers",
                                                "B": "Exactly 3 of the 5 signers",
                                                "C": "At least 3 of the 5 signers",
                                                "D": "All 5 signers must approve"
                                },
                                "correct": "C",
                                "explanation": "In a 3-of-5 multi-signature setup, at least 3 of the 5 designated signers must approve before a transaction can execute. So 3, 4, or all 5 signers approving would allow execution. This provides security against single points of failure (one compromised key can't drain funds) while maintaining operational efficiency (you don't need all 5 signers online). Multi-sig is crucial for DAO treasury management - it protects millions of dollars in treasury funds and ensures no single entity can unilaterally move assets."
                },
                {
                                "id": 14,
                                "difficulty": "hard",
                                "topic": "Governance attack vectors",
                                "question": "Which of the following is NOT a realistic governance attack vector for DAOs?",
                                "options": {
                                                "A": "Flash loan attack: Borrow tokens, vote, and return them in one transaction",
                                                "B": "Vote buying: Offering bribes to token holders via DeFi protocols",
                                                "C": "Quantum attack: Using quantum computing to break voting encryption",
                                                "D": "Low participation exploitation: Timing proposals during low-activity periods"
                                },
                                "correct": "C",
                                "explanation": "Quantum computing attacks on voting encryption are not currently a realistic governance attack vector. The real attacks are: Flash loan attacks (borrowing massive amounts to vote and returning them instantly), vote buying (bribing holders openly via protocols like Bribe.crv), whale dominance (large holders passing self-serving proposals), and low participation exploitation (attackers timing proposals when few people are paying attention). Flash loans are particularly dangerous for DAOs without proper safeguards like time-locked voting power or snapshot-based voting."
                },
                {
                                "id": 15,
                                "difficulty": "medium",
                                "topic": "Flash loan governance attacks",
                                "question": "What is the most effective defense mechanism against flash loan governance attacks?",
                                "options": {
                                                "A": "Requiring all voters to stake their tokens for the entire voting period",
                                                "B": "Increasing the gas cost of voting transactions",
                                                "C": "Using snapshot voting power that captures token balances before the proposal is created",
                                                "D": "Limiting the number of tokens that can participate in any single proposal"
                                },
                                "correct": "C",
                                "explanation": "Snapshot voting power - capturing token balances at a specific block before the proposal is created - is the most effective defense against flash loan attacks. Since flash loans must be borrowed and returned within a single transaction, the attacker's temporarily inflated balance won't be reflected in the historical snapshot. Alternative defenses include requiring tokens to be locked during voting or implementing time-weighted voting (tokens must be held for X days), but snapshot-based systems like Snapshot.org solve this elegantly without restricting token liquidity."
                },
                {
                                "id": 16,
                                "difficulty": "hard",
                                "topic": "Voter apathy problem",
                                "question": "Real-world DAO data shows that average voter participation is typically around 10-15%. What combination of factors BEST explains this persistent low turnout?",
                                "options": {
                                                "A": "High gas costs and lack of individual impact for small holders in token-weighted systems",
                                                "B": "Complex technical proposals and insufficient time given for voting periods",
                                                "C": "Too many simultaneous proposals overwhelming voters with decisions",
                                                "D": "Fear of legal liability for voting on governance proposals"
                                },
                                "correct": "A",
                                "explanation": "Low participation is primarily driven by high gas costs (on-chain voting can cost $10-50) and rational apathy - small holders know their vote has negligible impact in token-weighted systems where whales dominate. If you hold 100 tokens out of 1 billion supply (0.00001%), why pay $20 in gas to vote? This is why DAOs are moving to gas-free systems like Snapshot. Delegation helps but can further concentrate power. The problem is fundamental to token-weighted voting: the Pareto distribution of token holdings means most voters are rationally apathetic."
                },
                {
                                "id": 17,
                                "difficulty": "medium",
                                "topic": "Plutocracy concerns",
                                "question": "In most real DAOs, approximately what percentage of the total token supply do the top 10 holders typically control?",
                                "options": {
                                                "A": "10-20%",
                                                "B": "25-35%",
                                                "C": "40-60%",
                                                "D": "70-80%"
                                },
                                "correct": "C",
                                "explanation": "In most real DAOs, the top 10 holders control approximately 40-60% of the total token supply. Looking at the notebook's data: MakerDAO (48.2%), Uniswap (52.1%), Compound (57.8%), Aave (42.3%), and Curve (61.5%). This extreme concentration means a small group of whales effectively controls governance. This 'plutocracy' problem is inherent to token-weighted voting combined with the power-law distribution of crypto wealth. It's why alternative mechanisms like quadratic voting, reputation systems, and conviction voting are being explored."
                },
                {
                                "id": 18,
                                "difficulty": "hard",
                                "topic": "Optimistic governance",
                                "question": "What is the key principle behind optimistic governance mechanisms?",
                                "options": {
                                                "A": "All proposals are assumed to pass unless a quorum votes against them",
                                                "B": "Proposals are executed immediately and can be vetoed only during a challenge period",
                                                "C": "Only optimistic voters who expect proposals to succeed are allowed to vote",
                                                "D": "Proposals automatically pass if no one votes, optimistically assuming community approval"
                                },
                                "correct": "B",
                                "explanation": "Optimistic governance assumes proposals are legitimate and executes them immediately, but includes a challenge period during which token holders can veto malicious proposals. This inverts traditional governance: instead of needing a quorum to approve, you need significant opposition to block. This dramatically increases execution speed and reduces voter fatigue (people only need to pay attention when they disagree). However, it requires vigilant monitoring and fast response capabilities from the community, making it most suitable for low-risk parameter changes rather than major protocol upgrades."
                },
                {
                                "id": 19,
                                "difficulty": "medium",
                                "topic": "Governor contract (OpenZeppelin)",
                                "question": "What is the primary role of the OpenZeppelin Governor contract in DAO governance?",
                                "options": {
                                                "A": "To provide a standardized, audited implementation of on-chain governance logic",
                                                "B": "To automatically generate the optimal governance parameters for each DAO",
                                                "C": "To serve as a multi-signature wallet for DAO treasuries",
                                                "D": "To facilitate anonymous voting through zero-knowledge proofs"
                                },
                                "correct": "A",
                                "explanation": "The OpenZeppelin Governor contract provides a standardized, secure, and well-audited implementation of on-chain governance logic. It handles the full proposal lifecycle: proposal creation (with thresholds), voting period management, quorum checks, timelock integration, and execution. Using a battle-tested standard like Governor is much safer than building custom governance from scratch, as governance bugs can be catastrophic (see: The DAO hack). The Governor contract is modular and compatible with various token standards (ERC20Votes) and extensions (timelock, voting strategies)."
                },
                {
                                "id": 20,
                                "difficulty": "easy",
                                "topic": "Real DAO examples",
                                "question": "Which DAO pioneered decentralized governance for algorithmic stablecoins and is known for its MKR governance token?",
                                "options": {
                                                "A": "Uniswap DAO",
                                                "B": "Compound DAO",
                                                "C": "MakerDAO",
                                                "D": "Curve DAO"
                                },
                                "correct": "C",
                                "explanation": "MakerDAO pioneered decentralized governance for algorithmic stablecoins (DAI) using its MKR governance token. MKR holders vote on critical parameters like stability fees, collateral types, and risk parameters that keep DAI pegged to the dollar. MakerDAO is one of the oldest and largest DAOs, with over $5 billion in treasury assets. It established many governance practices now standard across DeFi, including proposal templates, executive votes, and on-chain polling. The system has successfully managed DAI through multiple market crises, demonstrating that DAO governance can work at scale."
                }
]
        };

        const state = {
            currentIndex: 0,
            answers: {},
            score: 0,
            displayedQuestions: [],
            pendingSlots: []
        };

        const questionsRow = document.getElementById('questionsRow');
        const progressBar = document.getElementById('progressBar');
        const progressBadge = document.getElementById('progressBadge');
        const scoreBadge = document.getElementById('scoreBadge');
        const resultsCard = document.getElementById('resultsCard');
        const nextBtn = document.getElementById('nextBtn');

        function initQuiz() {
            state.currentIndex = 0;
            state.answers = {};
            state.score = 0;
            state.displayedQuestions = [];
            state.pendingSlots = [];

            resultsCard.classList.remove('show');
            questionsRow.style.display = 'grid';
            nextBtn.classList.remove('show');

            // Show first 3 questions
            for (let i = 0; i < 3 && i < quizData.questions.length; i++) {
                state.displayedQuestions.push(i);
            }
            state.currentIndex = Math.min(3, quizData.questions.length);

            renderQuestions();
            updateStats();
        }

        function renderQuestions() {
            questionsRow.innerHTML = '';

            state.displayedQuestions.forEach((qIdx, slot) => {
                const q = quizData.questions[qIdx];
                const answered = state.answers[q.id] !== undefined;
                const isCorrect = answered && state.answers[q.id] === q.correct;
                const isIncorrect = answered && state.answers[q.id] !== q.correct;

                const card = document.createElement('div');
                card.className = 'question-card';
                if (isCorrect) card.classList.add('correct-card', 'answered');
                if (isIncorrect) card.classList.add('incorrect-card', 'answered');

                card.innerHTML = `
                    <div class="q-header">
                        <span class="q-number">Q${qIdx + 1}</span>
                        ${answered ? `<span class="q-status">${isCorrect ? '&#10004;' : '&#10008;'}</span>` : ''}
                    </div>
                    <div class="q-text">${q.question}</div>
                    <div class="options" data-qid="${q.id}" data-slot="${slot}">
                        ${['A','B','C','D'].map(letter => {
                            let optClass = 'option-btn';
                            if (answered) {
                                optClass += ' disabled';
                                if (letter === q.correct) optClass += ' correct';
                                else if (letter === state.answers[q.id]) optClass += ' incorrect';
                            }
                            return `
                                <button class="${optClass}" data-letter="${letter}" ${answered ? 'disabled' : ''}>
                                    <span class="option-letter">${letter}</span>
                                    <span class="option-text">${q.options[letter]}</span>
                                </button>
                            `;
                        }).join('')}
                    </div>
                    <div class="feedback ${answered ? 'show' : ''} ${isCorrect ? 'correct' : 'incorrect'}">
                        ${answered ? (isCorrect ? '&#10004; ' : `&#10008; Answer: ${q.correct}. `) + q.explanation : ''}
                    </div>
                `;

                // Add click handlers
                if (!answered) {
                    card.querySelectorAll('.option-btn').forEach(btn => {
                        btn.addEventListener('click', () => handleAnswer(qIdx, slot, btn.dataset.letter));
                    });
                }

                questionsRow.appendChild(card);
            });

            renderMath();
        }

        function handleAnswer(qIdx, slot, letter) {
            const q = quizData.questions[qIdx];
            state.answers[q.id] = letter;

            if (letter === q.correct) state.score++;

            // Track this slot as pending replacement
            if (!state.pendingSlots.includes(slot)) {
                state.pendingSlots.push(slot);
            }

            updateStats();
            renderQuestions();

            // Check if all questions answered
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                // Short delay then show results
                setTimeout(showResults, 800);
            } else if (state.currentIndex < quizData.questions.length && state.pendingSlots.length > 0) {
                // Show Next button if there are more questions and pending slots
                nextBtn.classList.add('show');
            }
        }

        function loadNextQuestions() {
            // Replace pending slots with new questions
            while (state.pendingSlots.length > 0 && state.currentIndex < quizData.questions.length) {
                const slot = state.pendingSlots.shift();
                state.displayedQuestions[slot] = state.currentIndex;
                state.currentIndex++;
            }

            // Hide Next button
            nextBtn.classList.remove('show');

            renderQuestions();

            // Check if quiz is complete (all displayed questions answered)
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                setTimeout(showResults, 500);
            }
        }

        function updateStats() {
            const answered = Object.keys(state.answers).length;
            const total = quizData.questions.length;

            progressBar.style.width = `${(answered / total) * 100}%`;
            progressBadge.textContent = `${answered}/${total}`;
            scoreBadge.textContent = `Score: ${state.score}`;
        }

        function showResults() {
            questionsRow.style.display = 'none';
            nextBtn.classList.remove('show');
            resultsCard.classList.add('show');

            const total = quizData.questions.length;
            const percentage = Math.round((state.score / total) * 100);

            document.getElementById('resultsScore').textContent = `${state.score}/${total}`;

            let grade, gradeClass, icon;
            if (percentage >= 90) { grade = 'Excellent! A'; gradeClass = 'grade-a'; icon = '&#127942;'; }
            else if (percentage >= 80) { grade = 'Great! B'; gradeClass = 'grade-b'; icon = '&#11088;'; }
            else if (percentage >= 70) { grade = 'Good! C'; gradeClass = 'grade-c'; icon = '&#128077;'; }
            else if (percentage >= 60) { grade = 'Pass - D'; gradeClass = 'grade-d'; icon = '&#128221;'; }
            else { grade = 'Keep practicing'; gradeClass = 'grade-f'; icon = '&#128218;'; }

            document.getElementById('resultsIcon').innerHTML = icon;
            const gradeEl = document.getElementById('resultsGrade');
            gradeEl.textContent = `${grade} (${percentage}%)`;
            gradeEl.className = `results-grade ${gradeClass}`;
        }

        function restartQuiz() {
            initQuiz();
        }

        function renderMath() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initQuiz();
            setTimeout(renderMath, 100);
        });
    </script>
</body>
</html>
